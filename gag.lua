-- Bundled Lua Script
-- Generated by Lua Bundler
-- https://github.com/alfin-efendy/lua-bundler

local EmbeddedModules = {}

-- Module: pet/egg.lua
EmbeddedModules["pet/egg.lua"] = function()
    local m = {}

    local Core
    local Player
    local Window
    local Garden
    local Pet
    local Webhook

    local AutoHatchConnection
    local IsHatchingInProgress = false

    function m:Init(_core, _player, _window, _garden, _pet, _webhook)
        Core = _core
        Player = _player
        Window = _window
        Garden = _garden
        Pet = _pet
        Webhook = _webhook

        local EggReadyToHatchRemote = Core.GameEvents.EggReadyToHatch_RE
        AutoHatchConnection = EggReadyToHatchRemote.OnClientEvent:Connect(function()
            self:StartAutoHatching()
        end)

        task.spawn(function()
            self:StartAutoHatching()
        end)
    end

    function m:StartAutoHatching()
        if not Window:GetConfigValue("AutoHatchEggs") then
            return
        end

        -- If already processing, don't start another process
        if IsHatchingInProgress then
            warn("Hatching already in progress, waiting...")
            return
        end

        IsHatchingInProgress = true

        -- Execute hatch
        self:HatchEgg()

        task.wait(1)
        IsHatchingInProgress = false
    end

    function m:StopAutoHatching()
        if AutoHatchConnection then
            AutoHatchConnection:Disconnect()
            AutoHatchConnection = nil
        end
    end

    function m:GetEggRegistry()
        local success, petRegistry = pcall(function()
            return require(Core.ReplicatedStorage.Data.PetRegistry)
        end)

        if not success then           
            warn("Failed to get pet registry:", petRegistry)
            return {}
        end

        local eggList = petRegistry.PetEggs
        if not eggList then
            warn("PetEggs is nil or not found")
            return {}
        end

        -- Return the eggList as-is for PetEggRenderer compatibility
        return eggList
    end

    function m:GetAllOwnedEggs()
        local myEggs = {}

        for _, tool in next, Player:GetAllTools() do
            local toolType = tool:GetAttribute("b")
            toolType = toolType and string.lower(toolType) or ""

            if toolType == "c" then
                table.insert(myEggs, tool)
            end
        end

        return myEggs
    end

    function m:FindEggOwnedEgg(eggName)
        for _, tool in next, self:GetAllOwnedEggs() do
            local toolName = tool:GetAttribute("h")

            if toolName == eggName then
                return tool
            end
        end
        return nil
    end

    function m:GetAllPlacedEggs()
        local placedEggs = {}
        local MyFarm = Garden:GetMyFarm()

        if not MyFarm then
            warn("My farm not found!")
            return placedEggs
        end

        local objectsPhysical = MyFarm.Important.Objects_Physical
        if not objectsPhysical then
            warn("Objects_Physical not found!")
            return placedEggs
        end

        for _, egg in pairs(objectsPhysical:GetChildren()) do
            if egg.Name ~= "PetEgg" then
                continue
            end

            local owner = egg:GetAttribute("OWNER")
            if owner == Core.LocalPlayer.Name then
                table.insert(placedEggs, egg)
            end
        end

        return placedEggs
    end

    function m:GetPlacedEggDetail(_eggID)
        local success, dataService = pcall(function()
            return require(Core.ReplicatedStorage.Modules.DataService)
        end)
        if not success or not dataService then
            warn("Failed to get DataService:", dataService)
            return nil
        end

        local allData = dataService:GetData()
        if not allData then
            warn("No data available from DataService")
            return nil
        end

        local saveSlots = allData.SaveSlots
        if not saveSlots then
            warn("SaveSlots not found in data")
            return nil
        end

        local savedObjects = saveSlots.AllSlots[saveSlots.SelectedSlot].SavedObjects

        if savedObjects and _eggID and savedObjects[_eggID] then
            return savedObjects[_eggID].Data
        end

        -- Fallback method
        warn("Falling back to ReplicationClass method")
        local replicationClass = Core.ReplicatedStorage.Modules.ReplicationClass
        local dataStreamReplicator = replicationClass.new("DataStreamReplicator")
        dataStreamReplicator:YieldUntilData()

        local replicationData = dataStreamReplicator:YieldUntilData().Table
        local playerData = replicationData[Core.LocalPlayer.Name] or replicationData[tostring(Core.LocalPlayer.UserId)]

        if playerData and playerData[_eggID] then
            return playerData[_eggID].Data
        end

        return nil
    end

    function m:PlacingEgg()
        local eggName = Window:GetConfigValue("EggPlacing") or ""
        local maxEggs = Window:GetConfigValue("MaxPlaceEggs") or 0
        local positionType = Window:GetConfigValue("PositionToPlaceEggs") or "Random"
        local position = Garden:GetFarmRandomPosition()

        if positionType == "Front Right" then
            position = Garden:GetFarmFrontRightPosition()
        elseif positionType == "Front Left" then
            position = Garden:GetFarmFrontLeftPosition()
        elseif positionType == "Back Right" then
            position = Garden:GetFarmBackRightPosition()
        elseif positionType == "Back Left" then
            position = Garden:GetFarmBackLeftPosition()
        end

        if eggName == "" then
            return
        end

        if maxEggs < 1 then
            return
        end

        local eggOwnedName = self:FindEggOwnedEgg(eggName)

        if not eggOwnedName then
            return
        end

        local totalOwnedEggs = eggOwnedName:GetAttribute("e") or 0
        local maxEggCanPlace = math.min(totalOwnedEggs, maxEggs)

        local placeEggTask = function(_maxEggCanPlace, _eggTool, _position, _positionType)
            local attemptCount = 0

            while #self:GetAllPlacedEggs() < _maxEggCanPlace do
                if Player:GetEquippedTool() ~= _eggTool then
                    Player:EquipTool(_eggTool)
                    task.wait(0.5) -- Small delay to ensure tool is equipped
                end

                local newPosition = Garden:GetFarmRandomPosition()

                local success, err = pcall(function()
                    if string.find(_positionType, "Front") then
                        local zPosition = _position.Z - (attemptCount * 5)
                        if Garden.MailboxPosition.Z > 0 then
                            zPosition = _position.Z + (attemptCount * 5)
                        end

                        newPosition = Vector3.new(_position.X, _position.Y, zPosition)
                    elseif string.find(_positionType, "Back") then
                        local zPosition = _position.Z + (attemptCount * 5)
                        if Garden.MailboxPosition.Z < 0 then
                            zPosition = _position.Z - (attemptCount * 5)
                        end

                        newPosition = Vector3.new(_position.X, _position.Y, zPosition)
                    end
                end)

                Core.GameEvents.PetEggService:FireServer("CreateEgg", newPosition)
                task.wait(0.15) -- Small delay to avoid spamming

                attemptCount = attemptCount + 1
            end
        end

        -- Add to queue with high priority (1)
        Player:AddToQueue(
            eggOwnedName,           -- tool
            1,                      -- priority (high)
            function()
                placeEggTask(maxEggCanPlace, eggOwnedName, position, positionType)
            end
        )
    end

    function m:HatchEgg()
        if #self:GetAllPlacedEggs() == 0 then
            self:PlacingEgg()
            while #self:GetAllPlacedEggs() < 1 do
                task.wait(1)
            end
        end

        -- Wait for eggs to be ready using while loop
        while true do
            local readyCount = 0
            local maxTimeToHatch = 0

            for _, egg in pairs(self:GetAllPlacedEggs()) do
                if not egg or not egg.Parent then -- Check if egg still exists
                    continue
                end

                local timeToHatch = egg:GetAttribute("TimeToHatch") or 0
                if timeToHatch > 0 then
                    maxTimeToHatch = math.max(maxTimeToHatch, timeToHatch)
                else
                    readyCount = readyCount + 1
                end
            end

            if readyCount == #self:GetAllPlacedEggs() then
                break
            end

            task.wait(math.min(maxTimeToHatch, 5)) -- Check every second
        end

        local hatchPetTeam = Window:GetConfigValue("HatchPetTeam") or nil
        local specialHatchPetTeam = Window:GetConfigValue("SpecialHatchPetTeam") or nil
        local specialHatchingPets = Window:GetConfigValue("SpecialHatchingPet") or {}
        local weightThresholdSpecialHatching = Window:GetConfigValue("WeightThresholdSpecialHatching") or math.huge
        local boostBeforeHatch = Window:GetConfigValue("AutoBoostBeforeHatch") or false
        local boostBeforeSpecialHatch = Window:GetConfigValue("AutoBoostBeforeSpecialHatch") or false

        if hatchPetTeam then
            Pet:ChangeTeamPets(hatchPetTeam, "hatch")
            task.wait(2)
            if boostBeforeHatch then
                Pet:BoostAllActivePets()
            end
        end

        local specialHatchingEgg = {}
        for _, egg in pairs(self:GetAllPlacedEggs()) do
            local eggUUID = egg:GetAttribute("OBJECT_UUID")
            local eggData = self:GetPlacedEggDetail(eggUUID)
            local baseWeight = eggData and eggData.BaseWeight or 1
            local petName = eggData and eggData.Type or "Unknown"

            local isSpecialPet = false
            for _, specialPet in ipairs(specialHatchingPets) do
                if petName == specialPet then
                    table.insert(specialHatchingEgg, egg)
                    isSpecialPet = true
                    break
                end
            end

            if isSpecialPet then
                continue
            end

            if baseWeight > weightThresholdSpecialHatching then
                table.insert(specialHatchingEgg, egg)
                continue
            end
            Core.GameEvents.PetEggService:FireServer("HatchPet", egg)
        end

        task.wait(1)

        if specialHatchPetTeam and #specialHatchingEgg > 0 then
            Pet:ChangeTeamPets(specialHatchPetTeam, "special_hatch")
            task.wait(2)
            if boostBeforeSpecialHatch then
                Pet:BoostAllActivePets()
            end
        end

        for _, egg in pairs(specialHatchingEgg) do
            local eggUUID = egg:GetAttribute("OBJECT_UUID")
            local eggData = self:GetPlacedEggDetail(eggUUID)
            local baseWeight = eggData and eggData.BaseWeight or 1
            local petName = eggData and eggData.Type or "Unknown"
            Core.GameEvents.PetEggService:FireServer("HatchPet", egg)
            task.wait(0.15) -- Small delay to avoid spamming

            task.spawn(function() 
                Webhook:HatchEgg(petName, egg:GetAttribute("EggName") or "Unknown", baseWeight)
            end)
        end

        if #specialHatchingEgg > 0 then
            task.wait(1)
        end


        local isAutoSellAfterHatch = Window:GetConfigValue("AutoSellPetsAfterHatching") or false
        local corePetTeam = Window:GetConfigValue("CorePetTeam") or nil

        if isAutoSellAfterHatch then
            Pet:SellPet()
        else
            Pet:ChangeTeamPets(corePetTeam, "core")
        end

        self:PlacingEgg()

        task.spawn(function()
            local eggName = Window:GetConfigValue("EggPlacing") or "N/A"
            local tooolEgg = self:FindEggOwnedEgg(eggName)
            local totalOwnedEggs = tooolEgg and (tooolEgg:GetAttribute("e") or 0) or 0

            Webhook:Statistics(eggName, totalOwnedEggs, Window:GetConfigValue("MaxPlaceEggs") or 0)
        end)
    end

    return m
end

-- Module: pet/pet.lua
EmbeddedModules["pet/pet.lua"] = function()
    local m = {}

    local Core
    local Player
    local Window
    local Garden
    local PetTeam
    local Webhook

    m.CurrentPetTeam = "core"

    function m:Init(_core, _player, _window, _garden, _petTeam, _webhook)
        Core = _core
        Player = _player
        Window = _window
        Garden = _garden
        PetTeam = _petTeam
        Webhook = _webhook

        Core:MakeLoop(function()
            return Window:GetConfigValue("AutoBoostPets")
        end, function()
            self:AutoBoostSelectedPets()
        end)

        Core:MakeLoop(function()
            return Window:GetConfigValue("AutoNightmareMutation")
        end, function()
            self:AutoNightmareMutation()
        end)

        Core:MakeLoop(function()
            return Window:GetConfigValue("AutoLevelingPets")
        end, function()
            self:StartAutoLeveling()
        end)
    end

    function m:GetPetReplicationData()
        local replicationClass = require(Core.ReplicatedStorage.Modules.ReplicationClass)
        local activePetsReplicator = replicationClass.new("ActivePetsService_Replicator")
        return activePetsReplicator:YieldUntilData().Table
    end

    function m:GetAllActivePets()
        local success, replicationData = pcall(function()
            return self:GetPetReplicationData()
        end)

        if not success then
            warn("🐾 [GET ACTIVE] Failed to get replication data:", replicationData)
            return nil
        end

        if not replicationData or not replicationData.ActivePetStates then
            warn("🐾 [GET ACTIVE] Invalid replication data structure")
            return nil
        end

        local activePetStates = replicationData.ActivePetStates
        local playerName = Core.LocalPlayer.Name
        local playerId = tostring(Core.LocalPlayer.UserId)

        -- Try multiple ways to find player's pets
        local playerPets = activePetStates[playerName] 
                        or activePetStates[playerId]
                        or activePetStates[tonumber(playerId)]

        if not playerPets then
            print("🐾 [GET ACTIVE] No active pets found for player:", playerName)
            -- Debug: Show available keys
            print("🐾 [GET ACTIVE] Available keys in ActivePetStates:")
            for key, _ in pairs(activePetStates) do
                print("  - Key:", key, "Type:", type(key))
            end
        end

        return playerPets
    end

    function m:GetPlayerPetData()
        local success, replicationData = pcall(self.GetPetReplicationData, self)
        if not success then
            warn("🐾 [GET DATA] Failed to get replication data:", replicationData)
            return nil
        end

        if not replicationData or not replicationData.PlayerPetData then
            warn("🐾 [GET DATA] Invalid PlayerPetData structure")
            return nil
        end

        local playerPetData = replicationData.PlayerPetData
        local playerName = Core.LocalPlayer.Name
        local playerId = tostring(Core.LocalPlayer.UserId)

        -- Try multiple ways to find player's data
        local playerData = playerPetData[playerName] 
                        or playerPetData[playerId]
                        or playerPetData[tonumber(playerId)]

        if not playerData then
            print("🐾 [GET DATA] No pet data found for player:", playerName)
            -- Debug: Show available keys
            print("🐾 [GET DATA] Available keys in PlayerPetData:")
            for key, _ in pairs(playerPetData) do
                print("  - Key:", key, "Type:", type(key))
            end
        end

        return playerData
    end

    function m:GetPetData(_petID)
        local playerData = self:GetPlayerPetData()
        if playerData and playerData.PetInventory then
            return playerData.PetInventory.Data[_petID]
        end
        return nil
    end

    function m:EquipPet(_petID)
        if not _petID then
            warn("🐾 [EQUIP] Invalid pet ID provided")
            return false
        end

        local success = pcall(function()
            local position = CFrame.new(Garden:GetFarmCenterPosition())
            if not position then
                error("Failed to get farm center position")
            end

            Core.GameEvents.PetsService:FireServer(
                "EquipPet",
                _petID,
                position
            )
        end)

        if not success then
            warn("🐾 [EQUIP] Failed to equip pet:", _petID)
            return false
        end

        return true
    end

    function m:UnequipPet(_petID)
        if not _petID then
            warn("🐾 [UNEQUIP] Invalid pet ID provided")
            return false
        end

        local success = pcall(function()
            Core.GameEvents.PetsService:FireServer(
                "UnequipPet",
                _petID
            )
        end)

        if not success then
            warn("🐾 [UNEQUIP] Failed to unequip pet:", _petID)
            return false
        end

        return true
    end


    function m:ChangeTeamPets(_teamName, _teamType)
        if not _teamName or _teamName == "" then
            return false
        end

        local pets = PetTeam:FindPetTeam(_teamName)

        if not pets or #pets == 0 then
            warn("🐾 [CHANGE TEAM] No pets found in the team:", _teamName)
            return false
        end

        -- Deactivate all current active pets
        local activePets = self:GetAllActivePets() or {}

        if not activePets then
            print("🐾 [CHANGE TEAM] No active pets to unequip")
        end

        for petID, _ in pairs(activePets) do
            local success = pcall(function()
                self:UnequipPet(petID)
            end)

            if not success then
                warn("🐾 [CHANGE TEAM] Failed to unequip pet:", petID)
            end

            task.wait(0.25) -- Longer delay to ensure server processes
        end

        -- Wait for unequip to complete
        task.wait(1)

        -- Activate pets in the selected team
        for _, petID in pairs(pets) do
            local success = pcall(function()
                self:EquipPet(petID)
            end)

            if not success then
                warn("🐾 [CHANGE TEAM] Failed to equip pet:", petID)
            end

            task.wait(0.25) -- Longer delay between equips
        end

        -- Final wait to ensure all equips are processed
        task.wait(1)

        self.CurrentPetTeam = _teamType

        return true
    end

    function m:BoostPet(_petID)
        Core.GameEvents.PetBoostService:FireServer(
            "ApplyBoost",
            _petID
        )
    end

    function m:EligiblePetUseBoost(_petID, _boostType, _boostAmount)
        local petData = self:GetPetData(_petID)
        local isEligible = true

        if not petData or not petData.PetData then
            return false
        end

        for key, value in pairs(petData.PetData) do
            if type(value) ~= "table" then
                continue
            end
            if key ~= "Boosts" and #value < 1 then
                continue
            end

            for i, boostInfo in ipairs(value) do
                local currentBoostType = boostInfo.BoostType
                local currentBoostAmount = boostInfo.BoostAmount

                if currentBoostType == _boostType and currentBoostAmount == _boostAmount then
                    isEligible = false
                end
            end
        end
        return isEligible
    end

    function m:BoostSelectedPets()
        local petIDs = Window:GetConfigValue("BoostPets") or {}
        if #petIDs == 0 then
            print("No pets selected for boosting.")
            return
        end

        local boostTypes = Window:GetConfigValue("BoostType") or {}
        if #boostTypes == 0 then
            print("No boost types selected.")
            return
        end

        for _, boostType in pairs(boostTypes) do
            local extractedType = {}
            for match in string.gmatch(boostType, "([^%-]+)") do
                table.insert(extractedType, match)
            end

            if #extractedType ~= 2 then
                warn("Invalid boost type format:", boostType)
                continue
            end

            local toolType = extractedType[1]
            local toolAmount = tonumber(extractedType[2])
            local boostTool = nil

            for _, tool in next, Player:GetAllTools() do
                local tType = tool:GetAttribute("q")
                local tAmount = tool:GetAttribute("o")

                if tType == toolType and tAmount == toolAmount then
                    boostTool = tool or nil
                    break
                end
            end

            if not boostTool then
                warn("No boost tool found for type:", boostType)
                return
            end

            local boostingPetTask = function(_petIDs, _boostType, _boostAmount, _boostTool)
                for _, petID in pairs(_petIDs) do
                    local isEligible = self:EligiblePetUseBoost(petID, _boostType, _boostAmount)

                    if not isEligible then
                        continue
                    end

                    self:BoostPet(petID)
                    task.wait(0.15)
                end
            end

            Player:AddToQueue(
                boostTool,               -- tool
                10,                  -- priority (high)
                function()
                    boostingPetTask(petIDs, toolType, toolAmount, boostTool)
                end    -- task function
            )
        end
    end

    function m:AutoBoostSelectedPets()
        local autoBoost = Window:GetConfigValue("AutoBoostPets") or false
        if not autoBoost then
            return
        end

        local petIDs = Window:GetConfigValue("BoostPets") or {}
        if #petIDs == 0 then
            print("No pets selected for boosting.")
            return
        end

        local boostTypes = Window:GetConfigValue("BoostType") or {}
        if #boostTypes == 0 then
            print("No boost types selected.")
            return
        end

        local hasEligiblePet = false
        for _, petID in pairs(petIDs) do
            for _, boostType in pairs(boostTypes) do
                local extractedType = {}
                for match in string.gmatch(boostType, "([^%-]+)") do
                    table.insert(extractedType, match)
                end
                if #extractedType ~= 2 then
                    continue
                end

                local toolType = extractedType[1]
                local toolAmount = tonumber(extractedType[2])
                local isEligible = self:EligiblePetUseBoost(petID, toolType, toolAmount)
                if isEligible then
                    hasEligiblePet = true
                    break
                end
            end
            if hasEligiblePet then
                break
            end
        end

        if not hasEligiblePet then
            return
        end

        self:BoostSelectedPets()
    end

    function m:BoostAllActivePets()
        local boostTool = {}

        for _, tool in next, Player:GetAllTools() do
            local toolType = tool:GetAttribute("q")

            if toolType == "PASSIVE_BOOST" then
                table.insert(boostTool, tool)
            end
        end

        if #boostTool == 0 then
            print("No boost tool found in inventory.")
            return
        end

        for _, tool in next, boostTool do
            local boostType = tool:GetAttribute("q")
            local boostAmount = tool:GetAttribute("o")
            local isTaskCompleted = false

            local boostingPetTask = function(_boostType, _boostAmount)
                print("🚀 Starting boost task for tool:", tool.Name)
                for petID, _ in pairs(self:GetAllActivePets()) do
                    local isEligible = self:EligiblePetUseBoost(petID, _boostType, _boostAmount)

                    if not isEligible then
                        continue
                    end

                    print("🐾 Boosting pet:", petID, "with", _boostType, "amount:", _boostAmount)
                    self:BoostPet(petID)
                    task.wait(0.15)
                end
            end

            local boostingPetCallback = function()
                isTaskCompleted = true
            end

            Player:AddToQueue(
                tool,               -- tool
                1,                  -- priority (high)
                function()
                    boostingPetTask(boostType, boostAmount)
                end,    -- task function
                function()
                    boostingPetCallback()
                end     -- callback function
            )

            -- Wait until task is completed
            while isTaskCompleted == false do
                task.wait(1)
            end
        end
    end

    function m:GetAllOwnedPets()
        local myPets = {}

        for _, tool in next, Player:GetAllTools() do
            local toolType = tool:GetAttribute("b")
            toolType = toolType or ""
            if toolType == "l" then
                table.insert(myPets, tool)
            end
        end

        return myPets
    end

    function m:GetPetDetail(_petID)
        local petMutationRegistry = require(Core.ReplicatedStorage.Data.PetRegistry.PetMutationRegistry)

        local petData = self:GetPetData(_petID)
        if not petData then
            warn("Pet data not found for UUID:", _petID)
            return nil
        end

        local petDetail = petData.PetData

        if not petDetail then
            warn("Pet detail is nil for UUID:", _petID)
            return nil
        end

        local isActive = false
        local activePets = self:GetAllActivePets() or {}
        for petID, _ in pairs(activePets) do
            if petID == _petID then
                isActive = true
                break
            end
        end

        local mutationType = petDetail.MutationType or ""
        local mutation = ""
            if petMutationRegistry and petMutationRegistry.EnumToPetMutation then
            mutation = petMutationRegistry.EnumToPetMutation[mutationType] or ""
        end

        return {
            ID = _petID,
            Name = petDetail.Name or "Unnamed",
            Type = petData.PetType or "Unknown",
            BaseWeight = petDetail.BaseWeight or 1,
            Age = petDetail.Level or 0,
            IsFavorited = petDetail.IsFavorited or false,
            IsActive = isActive,
            Mutation = mutation
        }
    end

    function m:GetAllMyPets()
        local myPets = {}
        local pets = {}

        for _, tool in pairs(self:GetAllOwnedPets()) do
            local petID = tool:GetAttribute("PET_UUID")
            if not petID then
                warn("Pet tool missing PET_UUID attribute:", tool.Name)
                continue
            end

            table.insert(pets, {
                ID = petID,
                IsActive = false
            })
        end

        for petID, _ in pairs(self:GetAllActivePets()) do
            if not petID then
                warn("Active pet entry missing PET_UUID")
                continue
            end

            table.insert(pets, {
                ID = petID,
                IsActive = true
            })
        end

        for _, pet in pairs(pets) do
            local petDetail = self:GetPetDetail(pet.ID)
            if not petDetail  then
                warn("Pet detail not found for UUID:", pet.ID)
                continue
            end

            table.insert(myPets, {
                ID = petDetail.ID,
                Name = petDetail.Name,
                Type = petDetail.Type,
                BaseWeight = petDetail.BaseWeight,
                Age = petDetail.Age,
                IsActive = pet.IsActive,
                IsFavorited = petDetail.IsFavorited,
                Mutation = petDetail.Mutation
            })
        end

        -- Sort by active status first, then by type, then by age descending
        table.sort(myPets, function(a, b)
            if a.IsActive ~= b.IsActive then
                return a.IsActive -- Active pets first
            elseif a.Type ~= b.Type then
                return a.Type < b.Type -- Alphabetical by type
            else
                return a.Age > b.Age -- Older pets first
            end
        end)

        return myPets
    end

    function m:SerializePet(pet)
        if not pet then return "" end
        local weight = tonumber(pet.BaseWeight) or 0
        local age = tonumber(pet.Age) or 0
        local mutationPrefix = (pet.Mutation and pet.Mutation ~= "") and ("[" .. pet.Mutation .. "] ") or ""
        local activeSuffix = pet.IsActive and " (Active)" or ""
        return string.format("%s%s %.2f KG (age %d) - %s%s",
            mutationPrefix,
            pet.Type or "Unknown",
            weight,
            age,
            pet.Name or "Unnamed",
            activeSuffix
        )
    end

    function m:GetPetRegistry()
        local success, petRegistry = pcall(function()
            return require(Core.ReplicatedStorage.Data.PetRegistry)
        end)

        if not success then           
            warn("Failed to get pet registry:", petRegistry)
            return {}
        end

        local petList = petRegistry.PetList
        if not petList then
            warn("PetList is nil or not found")
            return {}
        end

        -- Convert PetList to UI format {text = ..., value = ...}
        local formattedPets = {}
        for petName, petData in pairs(petList) do
            table.insert(formattedPets, {
                text = petName,
                value = petName
            })
        end

        if #formattedPets < 1 then
            return {}
        end

        -- Sort pets alphabetically (ascending order)
        table.sort(formattedPets, function(a, b)
            if not a or not b or not a.text or not b.text then
                return false
            end
            return string.lower(tostring(a.text)) < string.lower(tostring(b.text))
        end)

        return formattedPets
    end

    function m:SellPet()
        local petNames = Window:GetConfigValue("PetToSell") or {}
        local weighLessThan = Window:GetConfigValue("WeightThresholdSellPet") or 1
        local ageLessThan = Window:GetConfigValue("AgeThresholdSellPet") or 1
        local sellPetTeam = Window:GetConfigValue("SellPetTeam") or nil
        local boostBeforeSelling = Window:GetConfigValue("AutoBoostBeforeSelling") or false
        local corePetTeam = Window:GetConfigValue("CorePetTeam") or nil

        if #petNames == 0 then
            print("No pet selected for selling.")
            if corePetTeam then
                print("Reverting to Core Pet Team:", corePetTeam)
                self:ChangeTeamPets(corePetTeam, "core")
            end
            return
        end

        -- Favorite pets should not be sold
        for _, tool in pairs(self:GetAllOwnedPets()) do
            local isFavorited = tool:GetAttribute("d") or false
            if isFavorited then
                continue
            end

            local petID = tool:GetAttribute("PET_UUID")
            local petData = self:GetPetData(petID)
            if not petData then
                warn("Pet data not found for UUID:", petID)
                continue
            end

            local petName = petData.PetType or "Unknown"
            local petDetail = petData.PetData
            local petWeight = petDetail.BaseWeight or 20
            local petAge = petDetail.Level or math.huge

            local isPetNameMatched = false
            for _, selectedPet in ipairs(petNames) do
                if petName == selectedPet then
                    isPetNameMatched = true
                    break
                end
            end

            if petWeight >= weighLessThan or petAge >= ageLessThan or not isPetNameMatched then
                print("Skipping pet (does not meet sell criteria):", petName, "| Weight:", petWeight, "| Age:", petAge, "| Is Name Matched:", tostring(isPetNameMatched))

                Core.GameEvents.Favorite_Item:FireServer(tool)
                task.wait(0.15)
            end
        end

        task.wait(0.5) -- Wait for favorites to process

        if sellPetTeam then
            self:ChangeTeamPets(sellPetTeam, "sell")
            task.wait(2)
            if boostBeforeSelling then
                self:BoostAllActivePets()
            end
        end

        task.wait(1) -- Wait before selling

        Core.GameEvents.SellAllPets_RE:FireServer()
        task.wait(1) -- Wait for selling to process

        if corePetTeam then
            self:ChangeTeamPets(corePetTeam, "core")
        end
    end

    function m:GetModelPet(_petID)
            if not _petID then
            warn("Invalid pet ID provided")
            return nil
        end

        -- Cari di semua descendant
        for _, petMover in ipairs(workspace.PetsPhysical:GetChildren()) do
            local modelPet = petMover:FindFirstChild(_petID)
            if modelPet then
                print("Model ditemukan:", modelPet)
                return modelPet
            end
        end

        print("Model tidak ditemukan")
        return nil
    end

    function m:CleansingMutation(_petID)
        print("🐾 Cleansing mutation for pet ID:", _petID)
        if not _petID then
            warn("Invalid pet ID provided")
            return false
        end

        local cleansingTool
        for _, tool in next, Player:GetAllTools() do
            local toolName = tool:GetAttribute("u")

            if toolName == "Cleansing Pet Shard" then
                cleansingTool = tool or nil
                break
            end
        end

        if not cleansingTool then
            warn("No cleansing tool found")
            return false
        end

        local isTaskCompleted = false
        local cleansingTask = function(_petID)
            print("🐾 Applying cleansing shard to pet ID:", _petID)
            local petMover = self:GetModelPet(_petID)
            if not petMover then
                warn("PetMover not found for pet ID:", _petID)
                return
            end

            print("Firing ApplyShard for pet ID:", _petID, "Mover:", petMover)
            local success, error = pcall(function()
                Core.GameEvents.PetShardService_RE:FireServer(
                    "ApplyShard",
                    petMover
                )
            end)

            if not success then
                warn("Failed to apply cleansing shard:", error)
            end
            task.wait(1) -- Wait to ensure server processes the shard application
        end

        local cleansingCallback = function()
            isTaskCompleted = true
        end

        Player:AddToQueue(
            cleansingTool,               -- tool
            10,                  -- priority (high)
            function()
                cleansingTask(_petID)
            end,    -- task function
            function()
                cleansingCallback()
            end -- callback function
        )

        return true
    end

    function m:AutoNightmareMutation()
        print("🐾 Checking Auto Nightmare Mutation settings...")
        local autoNightmareMutation = Window:GetConfigValue("AutoNightmareMutation") or false
        if not autoNightmareMutation then
            print("Auto Nightmare Mutation is disabled.")
            return
        end

        local petIDs = Window:GetConfigValue("NightmareMutationPets") or {}
        if #petIDs == 0 then
            print("No pets selected for Nightmare Mutation.")
            return
        end

        local isPetIDAlreadyNightmare = ""
        local isNoActivePet = true

        for _, petID in pairs(petIDs) do
            print("Checking pet for Nightmare Mutation:", petID)
            local petDetail = self:GetPetDetail(petID)
            if not petDetail then
                warn("Pet detail not found for UUID:", petID)
                continue
            end

            print("Pet detail:", self:SerializePet(petDetail))
            if not petDetail.IsActive then
                print("Pet is not active, skipping Nightmare Mutation:", petDetail.Name)
                continue
            end

            isNoActivePet = false

            if petDetail.Mutation == "" then
                print("Pet has no mutation, skipping Cleansing Mutation:", petDetail.Name)
                continue
            end

            print("Checking mutation pet:", petDetail.Name)
            if petDetail.Mutation == "Nightmare" then
                print("Pet already has Nightmare mutation, skipping:", petDetail.Name)
                task.spawn(function() 
                    Webhook:NightmareMutation(petDetail.Type, #petIDs - 1)
                end)

                isPetIDAlreadyNightmare = petID
                break
            end

            print("Cleansing mutation for pet:", petDetail.Name)
            local success = self:CleansingMutation(petID)
            if not success then
                warn("Failed to cleanse mutation for pet:", petDetail.Name)
                continue
            end
        end

        if isPetIDAlreadyNightmare ~= "" then
            print("At least one selected pet already has Nightmare mutation. Aborting process.")

            self:UnequipPet(isPetIDAlreadyNightmare)
            task.wait(1)

            -- Remove from selected pets to avoid reprocessing
            for index, id in ipairs(petIDs) do
                if id == isPetIDAlreadyNightmare then
                    table.remove(petIDs, index)
                    break
                end
            end

            Window:SetConfigValue("NightmareMutationPets", petIDs)
            isNoActivePet = true
        end

        if not isNoActivePet then
            return
        end

        while m.CurrentPetTeam ~= "core" do
            print("Waiting to switch back to Core Pet Team...")
            task.wait(1)
        end

        print("No active pet found. Equipping the first selected pet:", petIDs[1])
        self:EquipPet(petIDs[1])
    end

    function m:StartAutoLeveling()
        local autoLeveling = Window:GetConfigValue("AutoLevelingPets") or false
        local levelToReach = Window:GetConfigValue("LevelToReach") or 100

        if not autoLeveling then
            print("Auto Leveling is disabled.")
            return
        end

        if levelToReach < 1 then
            print("Invalid level to reach for Auto Leveling:", levelToReach)
            return
        end

        local petIDs = Window:GetConfigValue("LevelingPets") or {}
        if #petIDs == 0 then
            print("No pets selected for Auto Leveling.")
            return
        end

        local isPetIDAlreadyAtTargetLevel = ""
        local isNoActivePet = true

        for _, petID in pairs(petIDs) do
            print("Starting Auto Leveling for pet:", petID)
            local petDetail = self:GetPetDetail(petID)
            if not petDetail then
                warn("Pet detail not found for UUID:", petID)
                continue
            end

            if not petDetail.IsActive then
                print("Pet is not active, skipping Auto Leveling:", petDetail.Name)
                continue
            end

            isNoActivePet = false
            if petDetail.Age >= levelToReach then
                print("Pet already reached the target level, skipping:", petDetail.Name)
                task.spawn(function() 
                    Webhook:AutoLeveling(petDetail.Type, levelToReach, #petIDs - 1)
                end)

                isPetIDAlreadyAtTargetLevel = petID
                break
            end
        end

        if isPetIDAlreadyAtTargetLevel ~= "" then
            print("At least one selected pet already reached the target level. Aborting process.")

            self:UnequipPet(isPetIDAlreadyAtTargetLevel)
            task.wait(1)

            -- Remove from selected pets to avoid reprocessing
            for index, id in ipairs(petIDs) do
                if id == isPetIDAlreadyAtTargetLevel then
                    table.remove(petIDs, index)
                    break
                end
            end

            Window:SetConfigValue("AutoLevelingPets", petIDs)

            isNoActivePet = true
        end

        if not isNoActivePet then
            return
        end

        while m.CurrentPetTeam ~= "core" do
            print("Waiting to switch back to Core Pet Team...")
            task.wait(1)
        end

        print("No active pet found. Equipping the first selected pet:", petIDs[1])
        self:EquipPet(petIDs[1])
    end

    return m
end

-- Module: pet/ui.lua
EmbeddedModules["pet/ui.lua"] = function()
    local m = {}
    local Window
    local PetTeam
    local Egg
    local Pet
    local Garden
    local Player

    function m:Init(_window, _petTeam, _egg, _pet, _garden, _player)
        Window = _window
        PetTeam = _petTeam
        Egg = _egg
        Pet = _pet
        Garden = _garden
        Player = _player
    end

    function m:CreatePetTab()
        local tab = Window:AddTab({
            Name = "Pet",
            Icon = "😺",
        })

        self:AddPetTeamsSection(tab)
        self:AddEggsSection(tab)
        self:AddSellSection(tab)
        self:BoostPetsSection(tab)
        self:AutoNightmareMutationSection(tab)
        self:AutoLevelingSection(tab)
    end

    function m:AddPetTeamsSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Pet Teams",
            Icon = "🛠️",
            Expanded = false,
        })

        local petTeamName = accordion:AddTextBox({
            Name = "Team Name",
            Placeholder = "Enter team name example: exp, hatch, sell, etc...",
            Default = "",
        })

        accordion:AddButton({Text = "Save Team", Callback = function()
            local teamName = petTeamName.GetText()
            if teamName and teamName ~= "" then
                print("Please enter a valid team name.")
            end

            local activePets = Pet:GetAllActivePets()
            if not activePets then
                print("No active pets found.")
                return
            end

            local listActivePets = {}
            for petID, petState in pairs(activePets) do
                table.insert(listActivePets, petID)
            end

            print("Creating pet team:", teamName)
            PetTeam:SaveTeamPets(teamName, listActivePets)
            petTeamName.Clear()
        end})

        accordion:AddSeparator()

        local selectTeam = accordion:AddSelectBox({
            Name = "Select a pet team to set as core, change, or delete.",
            Options = PetTeam:GetAllPetTeams(),
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                print("Get total pet teams:", #listTeamPet)

                for _, team in pairs(listTeamPet) do
                    print("Found pet team:", team)
                    table.insert(currentOptionsSet, {text = team, value = team})
                end

                updateOptions(currentOptionsSet)
            end
        })

        -- Declare labelCoreTeam variable first (forward declaration)
        local labelCoreTeam

        accordion:AddButton({Text = "Set Core Team", Callback = function()
            local selectedTeam = selectTeam.GetSelected()
            if selectedTeam and #selectedTeam > 0 then
                local teamName = selectedTeam[1]
                Window:SetConfigValue("CorePetTeam", teamName)
                labelCoreTeam:SetText("Current Core Team: " .. teamName)
            end    
        end})

        -- Create the label after the button
        labelCoreTeam = accordion:AddLabel("Current Core Team: " .. (Window:GetConfigValue("CorePetTeam") or "None"))

        accordion:AddSeparator()

        accordion:AddButton({Text = "Change Team", Callback = function()
            local selectedTeam = selectTeam.GetSelected()
            if selectedTeam and #selectedTeam > 0 then
                local teamName = selectedTeam[1]
                print("Changing to pet team:", teamName)
                Pet:ChangeTeamPets(teamName)    
            end
        end})

        accordion:AddButton({
            Text = "Delete Selected Team",
            Variant = "danger",
            Callback = function()
                local selectedTeam = selectTeam.GetSelected()
                if selectedTeam and #selectedTeam > 0 then
                    local teamName = selectedTeam[1]
                    PetTeam:DeleteTeamPets(teamName)
                    selectTeam.Clear()
                end
            end
        })
    end

    function m:AddEggsSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Eggs",
            Icon = "🥚",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select an egg to place in your farm",
            Options = {"Loading..."},
            Placeholder = "Select Egg...",
            MultiSelect = false,
            Flag = "EggPlacing",
           OnInit = function(api, optionsData)
                local formattedEggs = {}

                local listdEggs = Egg:GetEggRegistry()
                for egg, _ in pairs(listdEggs) do
                    table.insert(formattedEggs, {text = egg, value = egg})
                end

                -- Sort eggs alphabetically (ascending order)
                if #formattedEggs > 0 then
                    table.sort(formattedEggs, function(a, b)
                        if not a or not b or not a.text or not b.text then
                            return false
                        end
                        return string.lower(tostring(a.text)) < string.lower(tostring(b.text))
                    end)
                end

                optionsData.updateOptions(formattedEggs)
            end
        })

        accordion:AddNumberBox({
            Name = "Max Place Eggs",
            Placeholder = "Enter max eggs...",
            Default = 0,
            Min = 0,
            Max = 13,
            Increment = 1,
            Flag = "MaxPlaceEggs",
        })

        accordion:AddSelectBox({
            Name = "Position to Place Eggs",
            Options = {"Random", "Front Right", "Front Left", "Back Right", "Back Left"},
            Default = "Random",
            MultiSelect = false,
            Placeholder = "Select position...",
            Flag = "PositionToPlaceEggs",
        })

        accordion:AddButton({Text = "Place Selected Egg", Callback = function()
            Egg:PlacingEgg()    
        end})

        accordion:AddSeparator()

        accordion:AddSelectBox({
            Name = "Select Pet Team for Hatch",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "HatchPetTeam",
            OnInit = function(api, optionsData)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end

                updateOptions(currentOptionsSet)
            end
        })

        accordion:AddToggle({
            Name = "Auto Boost Pets Before Hatching",
            Default = false,
            Flag = "AutoBoostBeforeHatch",
        })

        accordion:AddSeparator()

        accordion:AddSelectBox({
            Name = "Select Special Pet",
            Options = {"Loading..."},
            Placeholder = "Select Special Pet...",
            MultiSelect = true,
            Flag = "SpecialHatchingPet",
           OnInit = function(api, optionsData)
                local specialPets = Pet:GetPetRegistry()
                optionsData.updateOptions(specialPets)
            end
        })

        accordion:AddLabel("Or If Weight is Higher Than")
        accordion:AddNumberBox({
            Name = "Weight Threshold",
            Placeholder = "Enter weight...",
            Default = 0.0,
            Min = 0.0,
            Max = 20.0,
            Increment = 1.0,
            Decimals = 2,
            Flag = "WeightThresholdSpecialHatching",
        })

        accordion:AddSelectBox({
            Name = "Select Pet Team for Special Hatch",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "SpecialHatchPetTeam",
            OnInit = function(api, optionsData)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end
        })

        accordion:AddToggle({
            Name = "Auto Boost Pets Before Special Hatching",
            Default = false,
            Flag = "AutoBoostBeforeSpecialHatch",
        })

        accordion:AddSeparator()

        accordion:AddToggle({
            Name = "Auto Hatch Eggs",
            Default = false,
            Flag = "AutoHatchEggs",
            Callback = function(value)
                if value then
                    Egg:StartAutoHatching()
                end
            end
        })
    end

    function m:AddSellSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Sell Pets",
            Icon = "💰",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select Pet to Sell",
            Options = {"Loading..."},
            Placeholder = "Select Pet...",
            MultiSelect = true,
            Flag = "PetToSell",
           OnInit = function(api, optionsData)
                local specialPets = Pet:GetPetRegistry()
                optionsData.updateOptions(specialPets)
            end,
        })

        accordion:AddNumberBox({
            Name = "And If Base Weight Is Less Than Or Equal",
            Placeholder = "Enter weight...",
            Default = 1.0,
            Min = 0.5,
            Max = 20.0,
            Increment = 1.0,
            Decimals = 2,
            Flag = "WeightThresholdSellPet",
        })

        accordion:AddNumberBox({
            Name = "And If Age Is Less Than Or Equal",
            Placeholder = "Enter age...",
            Default = 1,
            Min = 1,
            Max = 100,
            Increment = 1,
            Flag = "AgeThresholdSellPet",
        })

        accordion:AddSelectBox({
            Name = "Pet Team to Use for Selling",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "SellPetTeam",
            OnInit = function(api, optionsData)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetTeam:GetAllPetTeams()
                local currentOptionsSet = {}

                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end

                updateOptions(currentOptionsSet)
            end
        })
        accordion:AddToggle({
            Name = "Auto Boost Pets Before Selling",
            Default = false,
            Flag = "AutoBoostBeforeSelling",
        })

        accordion:AddToggle({
            Name = "Auto Sell Pets After Hatching",
            Default = false,
            Flag = "AutoSellPetsAfterHatching",
        })

        accordion:AddButton(
            {
                Text = "Sell Selected Pet",
                Variant = "warning",
                Callback = function()
                    Pet:SellPet()
                end
            }
        )
    end

    function m:BoostPetsSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Boost Pets",
            Icon = "⚡",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Pets Use for Boosting",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = true,
            Flag = "BoostPets",
            OnInit = function(api, optionsData)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                for _, pet in pairs(pets) do
                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                print("Total my pets:", #pets) -- Debug print

                for _, pet in pairs(pets) do
                    print("Pet ID:", pet.ID) -- Debug print
                    print("Type:", pet.Type, "Name:", pet.Name, "Age:", pet.Age, "Weight:", pet.BaseWeight, "Mutation:", pet.Mutation) -- Debug print
                    print("-----")

                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                updateOptions(currentOptionsSet)
            end
        })

        accordion:AddSelectBox({
            Name = "Boost Type",
            Options = {"Loading..."},
            Placeholder = "Select Boost Type...",
            MultiSelect = true,
            Flag = "BoostType",
            OnInit = function(api, optionsData)
                optionsData.updateOptions({
                    {text = "Small Toy", value = "PASSIVE_BOOST-0.1"},
                    {text = "Medium Toy", value = "PASSIVE_BOOST-0.2"},
                })
            end
        })

        accordion:AddButton({Text = "Boost Pets Now", Callback = function()
            Pet:BoostSelectedPets()
        end})

        accordion:AddToggle({
            Name = "Auto Boost Pets",
            Default = false,
            Flag = "AutoBoostPets",
            Callback = function(value)
                if value then
                    Pet:AutoBoostSelectedPets()
                end
            end
        })
    end

    function m:AutoNightmareMutationSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Nightmare Mutation",
            Icon = "🌑",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Target Pets for Nightmare Mutation",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = true,
            Flag = "NightmareMutationPets",
            OnInit = function(api, optionsData)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                for _, pet in pairs(pets) do
                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                for _, pet in pairs(pets) do
                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                updateOptions(currentOptionsSet)
            end
        })

        accordion:AddToggle({
            Name = "Auto Nightmare Mutation",
            Default = false,
            Flag = "AutoNightmareMutation",
            Callback = function(value)
                if value then
                    Pet:StartAutoNightmareMutation()
                end
            end
        })
    end

    function m:AutoLevelingSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Auto Leveling",
            Icon = "⬆️",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Pets Use for Auto Leveling",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = true,
            Flag = "LevelingPets",
            OnInit = function(api, optionsData)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                for _, pet in pairs(pets) do
                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                optionsData.updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local pets = Pet:GetAllMyPets()
                local currentOptionsSet = {}

                for _, pet in pairs(pets) do
                    table.insert(currentOptionsSet, {text = Pet:SerializePet(pet), value = pet.ID})
                end
                updateOptions(currentOptionsSet)
            end
        })

        accordion:AddNumberBox({
            Name = "Level To Reach",
            Placeholder = "Enter level...",
            Default = 100,
            Min = 1,
            Max = 100,
            Increment = 1,
            Flag = "LevelToReach",
        })

        accordion:AddToggle({
            Name = "Auto Leveling Pets",
            Default = false,
            Flag = "AutoLevelingPets",
            Callback = function(value)
                if value then
                    Pet:StartAutoLeveling()
                end
            end
        })
    end

    return m
end

-- Module: event/ghoul/quest.lua
EmbeddedModules["event/ghoul/quest.lua"] = function()
    local m = {}

    local Window
    local Core

    local BackpackConnection
    local LastSubmitTime

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        Core.GameEvents.WitchesBrew.UpdateCauldronVisuals.OnClientEvent:Connect(function(param)
            if not param and not param.Percentage then
                return
            end

            if param.Percentage == 0 then
                self:StartAutoSubmitEventPlants()
            end
        end)

        self:StartAutoSubmitEventPlants()
    end

    function m:StartAutoSubmitEventPlants()
        if not Window:GetConfigValue("AutoSubmitGhoulQuest") then
            return
        end

        if not BackpackConnection then
            BackpackConnection = Core:GetBackpack().ChildAdded:Connect(function(child)
                if not Window:GetConfigValue("AutoSubmitGhoulQuest") then
                    return
                end

                -- Debounce to prevent multiple submissions in quick succession
                if tick() - (LastSubmitTime or 0) < 5 then
                    return
                end

                if child:GetAttribute("b") ~= "j" then
                    return
                end

                Core.GameEvents.WitchesBrew.SubmitItemToCauldron:InvokeServer("All")
                LastSubmitTime = tick()
            end)
        end

        Core.GameEvents.WitchesBrew.SubmitItemToCauldron:InvokeServer("All")
        LastSubmitTime = tick()
    end

    function m:StopAutoSubmitEventPlants()
        if BackpackConnection then
            BackpackConnection:Disconnect()
            BackpackConnection = nil
        end
    end

    return m
end

-- Module: notification/ui.lua
EmbeddedModules["notification/ui.lua"] = function()
    local m = {}

    local Window
    local Test

    function m:Init(_window, _test)
        Window = _window
        Test = _test
    end

    function m:CreateNotificationTab()
        local tab = Window:AddTab({
            Name = "Notifications",
            Icon = "🔔",
        })

        tab:AddTextBox({
            Name = "Discord Webhook URL (for notifications)",
            Default = "",
            Flag = "DiscordWebhookURL",
            Placeholder = "https://discord.com/api/webhooks/...",
            MaxLength = 500,
        })

        tab:AddTextBox({
            Name = "Discord Ping ID (optional)",
            Default = "",
            Flag = "DiscordPingID",
            Placeholder = "123456789012345678",
            MaxLength = 50,
        })

        tab:AddButton(
            {Text = "Test Notification", 
            Callback = function()
                task.spawn(function()
                    Test:HatchEgg("Test Pet", "Test Egg", 10)
                    task.wait(0.15)
                    Test:Statistics("Test Egg", 99, 123)
                end)
        end})
    end

    return m
end

-- Module: shop/gear.lua
EmbeddedModules["shop/gear.lua"] = function()
    local m = {}

    local Window
    local Core
    local Shop

    local Connections
    local ShopUI = "Gear_Shop"
    local ShopItem = "Watering Can"

    function m:Init(_window, _core, _shop)
        Window = _window
        Core = _core
        Shop = _shop

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuyGear")
        end, function()
            self:BuyAllGear()
        end)
    end

    function m:BuyGear(gearName)
        if not gearName or gearName == "" then
            warn("Invalid gear name")
            return
        end

        Core.GameEvents.BuyGearStock:FireServer(gearName)
    end

    function m:BuyAllGear()
        local items = Shop:GetAvailableItems(ShopUI)

        for gearName, stock in pairs(items) do
            if stock < 1 then
                continue
            end

            for i = 1, stock do
                self:BuyGear(gearName)
                task.wait(0.1)
            end
        end
    end

    function m:StartGearAutomation()
        if not Window:GetConfigValue("AutoBuyGear") then
            return
        end

        self:BuyAllGear()

        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end

        Connections = {}
        for _, item in pairs(Shop:GetListItems(ShopUI)) do
            local conn = Shop:ConnectToStock(item, function()
                if not Window:GetConfigValue("AutoBuyGear") then
                    return
                end

                self:BuyAllGear()
            end)
            table.insert(Connections, conn)
        end
    end

    function m:StopGearAutomation()
        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end
    end

    return m
end

-- Module: shop/premium.lua
EmbeddedModules["shop/premium.lua"] = function()
    local m ={}

    local Window
    local Core

    function m:Init(_window, _core)
        Window = _window
        Core = _core
    end

    m.ListOfItems = {
        { text = "[4th July Event 2025] Liberty Lily", value = 3322972631 },
        { text = "[4th July Event 2025] Firework Flower", value = 3322974839 },
        { text = "[4th July Event 2025] Firework", value = 3322978636 },
        { text = "[4th July Event 2025] Bald Eagle", value = 3322970897 },
        { text = "[4th July Event 2025] July 4th Crate", value = 3322970196 },
        { text = "[Halloween Event] Bloodred Mushroom", value = 3426534747 },
        { text = "[Halloween Event] Jack O Lantern", value = 3426535112 },
        { text = "[Halloween Event] Ghoul Root", value = 3426535875 },
        { text = "[Halloween Event] Chicken Feed", value = 3426536221 },
        { text = "[Halloween Event] Seer Vine", value = 3426536516 },
        { text = "[Halloween Event] Poison Apple", value = 3426537228 },
        { text = "[Halloween Event] Spooky Egg", value = 3426500875 },
        { text = "[Halloween Event] Pumpkin Rat", value = 3426530616 },
        { text = "[Halloween Event] Ghost Bear", value = 3426533454 },
        { text = "[Halloween Event] Wolf", value = 3426533989 },
        { text = "[Halloween Event] Reaper", value = 3426534351 },
        { text = "[Halloween Event] Pumpkin Crate", value = 3426537997 },
        { text = "[Halloween Event] Ghost Lantern", value = 3426539369 },
        { text = "[Halloween Event] Tombstones", value = 3426539598 },
        { text = "[Halloween Event] Casket", value = 3426540158 },
        { text = "[Halloween Event] Skull Chain", value = 3426540522 },
    }

    function m:BuyItemWithRobux()
        print("Attempting to purchase item from Premium Shop...")
        local premiumItem = Window:GetConfigValue("PremiumShopItem")
        local premiumProductID = tonumber(Window:GetConfigValue("PremiumShopProductID"))

        if not premiumProductID then
            premiumProductID = premiumItem
        end

        if not premiumItem then
            warn("Please select a valid item to purchase.")
            return
        end

        if not premiumProductID or premiumProductID <= 0 then
            warn("Please enter a valid Product ID.")
            return
        end

        Core.MarketplaceService:PromptProductPurchase(Core.LocalPlayer, premiumProductID)
    end

    return m
end

-- Module: inventory/inventory.lua
EmbeddedModules["inventory/inventory.lua"] = function()
    local m = {}

    local Core
    local Player
    local Window

    local InventoryConnection

    function m:Init(_core, _player, _window)
        Core = _core
        Player = _player
        Window = _window

        InventoryConnection = Core:GetBackpack().ChildAdded:Connect(function(child)
            self:AutoFavoritePet(child)
        end)
    end

    function m:GetAllPets()
        local myPets = {}

        for _, tool in next, Player:GetAllTools() do
            local toolType = tool:GetAttribute("b")
            toolType = toolType and string.lower(toolType) or ""
            if toolType == "l" then
                table.insert(myPets, tool)
            end
        end

        return myPets
    end

    function m:FavoriteItem(item)
        Core.GameEvents.Favorite_Item:FireServer(item)
        task.wait(0.15)
    end

    function m:AutoFavoritePet(item)
        if not item or not item:IsA("Tool") then
            return
        end 

        local isAutoFavoriting = Window:GetConfigValue("AutoFavoritePets") or false
        if not isAutoFavoriting then return end

        local petType = item:GetAttribute("b")
        if not petType or string.lower(petType) ~= "l" then
            return
        end

        local isFavorited = item:GetAttribute("d") or false
        if isFavorited then
            return
        end

        local petNames = Window:GetConfigValue("AutoFavoritePetName") or {}
        local weightThreshold = Window:GetConfigValue("AutoFavoritePetWeight") or 0.0
        local ageThreshold = Window:GetConfigValue("AutoFavoritePetAge") or 0

        -- Parse pet name, weight, and age from item.Name
        -- Example format: "Golden Goose [2.19 KG] [Age 2]"
        local petName, weightStr, ageStr = item.Name:match("^(.-)%s*%[(.-)%s*KG%]%s*%[Age%s*(%d+)%]")

        if not petName then
            -- Fallback if parsing fails
            petName = item.Name
            weightStr = nil
            ageStr = nil
        end

        local weight = weightStr and tonumber(weightStr:match("%d+%.?%d*")) or 0
        local age = ageStr and tonumber(ageStr) or 0

        print(string.format("Checking pet: %s | Weight: %.2f | Age: %d", petName, weight, age))

        for _, name in ipairs(petNames) do
            if petName == name then
                print("Auto-favoriting pet by name:", petName)
                self:FavoriteItem(item)
                return
            end
        end

        if weight >= weightThreshold or age >= ageThreshold then
            self:FavoriteItem(item)
        end
    end

    function m:FavoriteAllPets()
        for _, tool in pairs(self:GetAllPets()) do
            self:AutoFavoritePet(tool)
        end
    end

    return m
end

-- Module: farm/ui.lua
EmbeddedModules["farm/ui.lua"] = function()
    local m = {}
    local Window
    local Player
    local Garden
    local Plant

    function m:init(_window, _player, _garden, _plant)
        Window = _window
        Player = _player
        Garden = _garden
        Plant = _plant
    end

    function m:CreateFarmTab()
        local tab = Window:AddTab({
            Name = "Farm",
            Icon = "🌾",
        })

        self:AddPlantingSection(tab)
        self:AddWateringSection(tab)
        self:AddHarvestingSection(tab)
        self:AddMovingSection(tab)
    end

    function m:AddPlantingSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Planting",
            Icon = "🌱",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select seeds to auto plant",
            Options = {"Loading..."},
            Placeholder = "Select seeds...",
            MultiSelect = true,
            Flag = "SeedsToPlant",
           OnInit = function(api, optionsData)
                local seeds = Plant:GetPlantRegistry()
                local formattedSeeds = {}
                for _, seedData in pairs(seeds) do
                    table.insert(formattedSeeds, {
                        text = seedData.plant,
                        value = seedData.plant
                    })
                end
                optionsData.updateOptions(formattedSeeds)
            end,
        })

        accordion:AddNumberBox({
            Name = "Set the number of seeds to plant",
            Placeholder = "Enter number of seeds...",
            Flag = "SeedsToPlantCount",
            Min = 0,
            Max = 800,
            Default = 1,
            Increment = 1,
        })

        accordion:AddSelectBox({
            Name = "Position planting seeds",
            Flag = "PlantingPosition",
            Options = {"Random", "Front Right", "Front Left", "Back Right", "Back Left"},
            Default = "Random",
            MultiSelect = false,
            Placeholder = "Select position...",
        })

        accordion:AddButton({Text = "Manual Planting", Callback = function()
            local selectedSeeds = Window:GetConfigValue("SeedsToPlant") or {}
            local seedsToPlantCount = Window:GetConfigValue("SeedsToPlantCount") or 1

            print("Selected Seeds:", selectedSeeds)
            print("Number of Seeds to Plant:", seedsToPlantCount)

            Plant:PlantSeed(selectedSeeds[1], seedsToPlantCount)
        end})

        accordion:AddToggle({
            Name = "Enable Auto Planting",
            Flag = "AutoPlantSeeds",
            Default = false,
            Callback = function(state)
               if state then
                    print("Auto Planting Enabled:", state)
                    Plant:StartAutoPlanting()
                else
                    print("Auto Planting Disabled:", state)
                end
            end,
        })
    end

    function m:AddWateringSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Watering",
            Icon = "💧",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Watering Position",
            Flag = "WateringPosition",
            Options = {"Growing Plants", "Front Right", "Front Left", "Back Right", "Back Left"},
            Default = "Front Right",
            MultiSelect = false,
            Placeholder = "Select position...",
        })

        accordion:AddNumberBox({
            Name = "Set the Each Watering",
            Placeholder = "Enter number of waterings...",
            Flag = "WateringEach",
            Min = 1,
            Max = 100,
            Default = 1,
            Increment = 1,
        })

        accordion:AddNumberBox({
            Name = "Set the number of waterings delay",
            Placeholder = "Enter watering delay...",
            Flag = "WateringDelay",
            Min = 0,
            Max = 800,
            Default = 1,
            Increment = 1,
        })

        accordion:AddToggle({
            Name = "Enable Auto Watering",
            Flag = "AutoWateringPlants",
            Default = false,
            Callback = function(state)
               if state then
                    print("Auto Watering Enabled:", state)
                    Plant:AutoWateringPlants()
                else
                    print("Auto Watering Disabled:", state)
                end
            end,
        })
    end

    function m:AddHarvestingSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Harvest",
            Icon = "🌿",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select plants to auto harvest",
            Flag = "PlantsToHarvest",
            MultiSelect = true,
            Placeholder = "Select plants...",
           OnInit = function(api, optionsData)
                local plants = Plant:GetPlantRegistry()
                local formattedPlants = {}
                for _, plantData in pairs(plants) do
                    table.insert(formattedPlants, {
                        text = plantData.plant,
                        value = plantData.plant,
                    })
                end
                optionsData.updateOptions(formattedPlants)
            end,
        })

        accordion:AddToggle({
            Name = "Auto Harvest Plants 🌿",
            Default = false,
            Flag = "AutoHarvestPlants",
            Callback = function(Value)
                if Value then
                    Plant:StartAutoHarvesting()
                end
            end,
        })
    end

    function m:AddMovingSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Move Plants",
            Icon = "🚜",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select plant to move",
            Flag = "PlantToMove",
            MultiSelect = false,
            Placeholder = "Select plant...",
           OnInit = function(api, optionsData)
                local plants = Plant:GetPlantRegistry()
                local formattedPlants = {}
                for _, plantData in pairs(plants) do
                    table.insert(formattedPlants, {
                        text = plantData.plant,
                        value = plantData.plant,
                    })
                end
                optionsData.updateOptions(formattedPlants)
            end,
        })

        accordion:AddSelectBox({
            Name = "Select destination",
            Flag = "MoveDestination",
            Options = {"Front Right", "Front Left", "Back Right", "Back Left"},
            Default = "Front Right",
            MultiSelect = false,
            Placeholder = "Select destination...",
        })

        accordion:AddButton({Text = "Move Plant", Callback = function()
            Plant:MovePlant()
        end})
    end

    return m
end

-- Module: quest/ascension.lua
EmbeddedModules["quest/ascension.lua"] = function()
    local m = {}

    local Window
    local Core
    local Plant
    local Player

    function m:Init(_window, _core, _plant, _player)
        Window = _window
        Core = _core
        Plant = _plant
        Player = _player

        Core:MakeLoop(function()
            return Window:GetConfigValue("AutoAscend")
        end, function()
            self:AutoSubmitQuest()
        end)
    end

    function m:GetQuestDetail()
        local UI = Core:GetPlayerGui():FindFirstChild("RebirthConfirmation")
        if not UI then
            warn("RebirthConfirmation UI not found")
            return nil
        end

        local frame = UI:FindFirstChild("Frame")
        if not frame then
            warn("Frame not found in RebirthConfirmation UI")
            return nil
        end

        local rebirthSubmitTime = frame.Frame:FindFirstChild("AscensionTimer")

        local questDetail = frame.Display.RebirthDetails:FindFirstChild("RequiredItemTemplate")
        if not questDetail then
            warn("RequiredItemTemplate not found")
            return nil
        end

        local itemName = questDetail:FindFirstChild("ItemName")
        if not itemName then
            warn("ItemName not found")
            return nil
        end

        local itemAmount = questDetail:FindFirstChild("ItemAmount")
        if not itemAmount then
            warn("ItemAmount not found")
            return nil
        end

        local itemMutations = questDetail:FindFirstChild("ItemMutations")
        if not itemMutations then
            warn("ItemMutations not found")
            return nil
        end

        -- Parse text with color tags
        local function parseText(text)
            if not text then return "" end
            -- Remove color tags like <font color="#6cb8ff">Frozen</font>
            return text:gsub('<font[^>]*>', ''):gsub('</font>', '')
        end

        local parsedName = itemName.Text
        local parsedAmount = tonumber(itemAmount.Text:match("%d+"))
        local parsedMutations = parseText(itemMutations.Text)
        local isEligibleToSubmit = not rebirthSubmitTime.Visible
        local nextRebirthSubmitTime = 0
        if rebirthSubmitTime.Visible then
            local text = rebirthSubmitTime.Text
            local hours = tonumber(text:match("(%d+)h")) or 0
            local minutes = tonumber(text:match("(%d+)m")) or 0
            local seconds = tonumber(text:match("(%d+)s")) or 0
            local totalSeconds = (hours * 3600) + (minutes * 60) + seconds
            nextRebirthSubmitTime = tick() + totalSeconds
        end

        return {
            Name = parsedName,
            Amount = parsedAmount,
            Mutations = parsedMutations,
            IsEligibleToSubmit = isEligibleToSubmit,
            NextRebirthSubmitTime = nextRebirthSubmitTime
        }
    end

    function m:IsQuestFruit(_fruit)
        local isEligible = false

        if not _fruit:IsA("Tool") then
            return isEligible
        end

        if _fruit:GetAttribute("b") ~= "j" then
            return isEligible
        end

        local quest = self:GetQuestDetail()
        if not quest then
            return isEligible
        end

        if _fruit:GetAttribute("f") ~= quest.Name then
            return isEligible
        end

        if not quest.Mutations or quest.Mutations == "" or quest.Mutations == "N/A" then
            return true
        end

        for attributeName, attributeValue in pairs(_fruit:GetAttributes()) do
            if attributeValue == true and attributeName == quest.Mutations then
                isEligible = true
                break
            end
        end

        return isEligible
    end

    function m:GetAllOwnedFruitsQuest()
        local myFruits = {}

        for _, fruit in pairs(Core:GetBackpack():GetChildren()) do
            if self:IsQuestFruit(fruit) then
                table.insert(myFruits, fruit)
            end
        end

        return myFruits
    end

    function m:SubmitRebirth(fruit)
        local quest = self:GetQuestDetail()
        if not quest or not quest.IsEligibleToSubmit then
            task.wait(quest.NextRebirthSubmitTime - tick() + 1)
        end

        local rebirthTask = function()
            Core.GameEvents.BuyRebirth:FireServer()

            wait(1)
        end

        Player:AddToQueue(fruit, 10, function()
            rebirthTask()
        end)
    end

    function m:AutoSubmitQuest()
        local quest = self:GetQuestDetail()
        if not quest then
            return
        end

        local ownedFruits = self:GetAllOwnedFruitsQuest()
        if ownedFruits and #ownedFruits >= quest.Amount then
            self:SubmitRebirth(ownedFruits[1])
        end

        local plants = Plant:FindPlants(quest.Name) or {}
        if not plants or #plants < quest.Amount then
            warn("Not enough plants found for quest:", quest.Name)

            local plantingPosition = Window:GetConfigValue("PlantingAscensionPosition") or "Random"

            Plant:PlantSeed(quest.Name, quest.Amount - #plants, plantingPosition)
            return
        end

        local plantToHarvest = {}
        for _, plant in pairs(plants) do
            if #plantToHarvest >= quest.Amount then
                break
            end
            if plant.name ~= quest.Name then
                continue
            end

            -- Get mutation name from attributes (key with value = true)
            local plantDetail = Plant:GetPlantDetail(plant)
            if not plantDetail or #plantDetail.fruits == 0 then
                continue
            end
            for _, fruit in pairs(plantDetail.fruits) do
                if not fruit.isEligibleToHarvest then
                    continue
                end

                if not quest.Mutations or quest.Mutations == "" or quest.Mutations == "N/A" then
                    table.insert(plantToHarvest, fruit.model)
                    break
                end

                for _, mutation in pairs(fruit.mutations) do
                    if mutation == quest.Mutations then
                        table.insert(plantToHarvest, fruit.model)
                        break
                    end
                end
            end
        end

        if not plantToHarvest or #plantToHarvest == 0 then
            return
        end

        -- Harvesting fruits
        local harvestedCount = 0
        for _, fruit in pairs(plantToHarvest) do
            if harvestedCount >= quest.Amount then
                break
            end

            local success = Plant:HarvestFruit(fruit)
            if success then
                harvestedCount = harvestedCount + 1
                task.wait(0.15) -- Small delay between harvests
            end
        end
    end

    return m
end

-- Module: shop/ui.lua
EmbeddedModules["shop/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local EggShop
    local SeedShop
    local GearShop
    local SeasonPassShop
    local TravelingShop
    local PremiumShop

    function m:Init(_window, _core, _eggShop, _seedShop, _gearShop, _seasonPassShop, _travelingShop, _premiumShop)
        Window = _window
        Core = _core
        EggShop = _eggShop
        SeedShop = _seedShop
        GearShop = _gearShop
        SeasonPassShop = _seasonPassShop
        TravelingShop = _travelingShop
        PremiumShop = _premiumShop
    end

    function m:CreateShopTab()
        local tab = Window:AddTab({
            Name = "Shop",
            Icon = "🛍️",
        })

        -- Seed Automation
        tab:AddToggle({
            Name = "Auto Buy Seeds 🌱",
            Default = false,
            Flag = "AutoBuySeeds",
            Callback = function(Value)
                if Value then
                    SeedShop:BuyAllSeeds()
                end
            end,
        })

        -- Gear Automation
        tab:AddToggle({
            Name = "Auto Buy Gear 🛠️",
            Default = false,
            Flag = "AutoBuyGear",
            Callback = function(Value)
                if Value then
                    GearShop:BuyAllGear()
                end
            end,
        })

        -- Egg Automation
        tab:AddToggle({
            Name = "Auto Buy Eggs 🥚",
            Default = false,
            Flag = "AutoBuyEggs",
            Callback = function(Value)
                if Value then
                    EggShop:BuyAllEggs()
                end
            end,
        })

        tab:AddToggle({
            Name = "Auto Buy Traveling Items 🧳",
            Default = false,
            Flag = "AutoBuyTravelingMerchant",
            Callback = function(Value)
                if Value then
                    TravelingShop:BuyAllTravelingItems()
                end
            end,
        })

        -- Season Pass Automation
        tab:AddToggle({
            Name = "Auto Buy Season Pass Items 🎟️",
            Default = false,
            Flag = "AutoBuySeasonPasses",
            Callback = function(Value)
                if Value then
                    SeasonPassShop:BuyAllSeasonPassItems()
                end
            end,
        })

        self:PremiumShopSection(tab)
    end

    function m:PremiumShopSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Premium Shop ",
            Icon = "💎",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select Item to Buy 🛒",
            Options = PremiumShop.ListOfItems,
            Placeholder = "Select Item",
            MultiSelect = false,
            Flag = "PremiumShopItem"
        })

        accordion:AddTextBox({
            Name = "Product ID (for custom item)",
            Default = "",
            Flag = "PremiumShopProductID",
            Placeholder = "example: 3322970897",
            MaxLength = 50,
            Buttons = {
                {
                    Text = "Paste 📋",
                    Variant = "primary", 
                    Callback = function(text, textBox)
                        print("Pasting from clipboard...")
                        -- text.text = tostring(Core.ClipboardService:GetClipboard())
                    end
                },
                {
                    Text = "Clear ✖️",
                    Variant = "destructive", 
                    Callback = function(text, textBox)
                        text.text = ""
                    end
                }
            }
        })

        accordion:AddButton({
            Name = "Purchase Item 🛒",
            Callback = function()
                PremiumShop:BuyItemWithRobux()
            end
        })
    end

    return m
end

-- Module: pet/team.lua
EmbeddedModules["pet/team.lua"] = function()
    local m = {}

    local Core
    local Player
    local Window
    local PetConfig
    local Garden

    function m:Init(_core, _player, _window, _petConfig, _garden)
        Core = _core
        Player = _player
        Window = _window
        PetConfig = _petConfig
        Garden = _garden
    end

    function m:SaveTeamPets(_teamName, _listPets)
        PetConfig:SetValue(_teamName, _listPets)
    end

    function m:GetAllPetTeams()
        print("Fetching all pet teams from configuration...")
        local allKeys = PetConfig:GetAllKeys()

        return allKeys
    end

    function m:FindPetTeam(_teamName)
        return PetConfig:GetValue(_teamName)
    end

    function m:DeleteTeamPets(_teamName)
        PetConfig:DeleteKey(_teamName)
    end

    return m
end

-- Module: pet/webhook.lua
EmbeddedModules["pet/webhook.lua"] = function()
    local m = {}

    local Window
    local Core
    local Discord

    local PlayerName
    local LastHatchTime = 0
    local HatchCount = 0
    local HatchTotal = 0
    local InitialStockEgg = {}

    function m:Init(_window, _core, _discord)
        Window = _window
        Core = _core
        Discord = _discord

        PlayerName = Core.LocalPlayer.Name or "Unknown"
        LastHatchTime = tick()
    end

    function m:HatchEgg(_petName, _eggName, _baseWeight)
        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        local pingId = Window:GetConfigValue("DiscordPingID") or ""
        if url == "" then
            return
        end

        local weightStatus = (
            (_baseWeight >= 9 and "Godly") or
            (_baseWeight >= 8 and _baseWeight < 9 and "Titanic") or
            (_baseWeight >= 3 and _baseWeight < 8 and "Huge") or
            "Small"
        )

        local message = {
            content = pingId ~= "" and ("<@"..pingId..">") or nil,
            embeds = {{
                title = "**EzGarden**",
                type = 'rich',
                color = tonumber("0xfa0c0c"),
                fields = {{
                    name = '**Profile : ** \n',
                    value = '> Username : ||'..PlayerName.."||",
                    inline = false
                }, {
                    name = "**Hatched : **",
                    value = "> Pet Name: ``".._petName.."``"..
                           "\n> Hatched From: ``"..(_eggName or"N/A").."``"..
                           '\n> Weight: ``'..(tostring(_baseWeight).." KG" or 'N/A')..'``'..
                           "\n> Weight Status: ``"..weightStatus.."``",
                    inline = false
                }}
            }}
        }

        Discord:SendMessage(url, message)
    end

    function m:Statistics(_eggName, _amount, _hatchedEgg)
        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        if url == "" then
            return
        end

        if InitialStockEgg[_eggName] == nil then
            InitialStockEgg[_eggName] = _amount
        end

        HatchCount = HatchCount + 1
        HatchTotal = HatchTotal + _hatchedEgg

        local message = {
            content = "",
            embeds = {{
                title = "**EzGarden**",
                type = 'rich',
                color = tonumber("0xFFFF00"),
                fields = {{
                    name = '**Profile : ** \n',
                    value = '> Username : ||'..PlayerName.."||",
                    inline = false
                }, {
                    name = "**Hatch Statistics : **",
                    value = "> Egg Name: ``"..(_eggName or"N/A").."``"..
                            '\n> Initial Stock: ``'..(tostring(InitialStockEgg[_eggName]) or 'N/A')..'``'..
                            '\n> Current Amount: ``'..(tostring(_amount) or 'N/A')..'``'..
                            '\n> Hatch Count: ``'..(tostring(HatchCount) or 'N/A')..'``'..
                            '\n> Total Hatched: ``'..(tostring(HatchTotal) or 'N/A')..'``'..
                            '\n> Duration: ``'..string.format("%d Minutes %d Seconds", math.floor((tick() - LastHatchTime) / 60), math.floor((tick() - LastHatchTime) % 60))..'``',
                    inline = false
                }}
            }}
        }

        LastHatchTime = tick()
        Discord:SendMessage(url, message)
    end

    function m:NightmareMutation(_petType, _remains)
        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        local pingId = Window:GetConfigValue("DiscordPingID") or ""
        if url == "" then
            return
        end

        local message = {
            content = pingId ~= "" and ("<@"..pingId..">") or nil,
            embeds = {{
                title = "**EzGarden**",
                type = 'rich',
                color = tonumber("0x8B00FF"),
                fields = {{
                    name = '**Profile : ** \n',
                    value = '> Username : ||'..PlayerName.."||",
                    inline = false
                }, {
                    name = "**Nightmare Mutation : **",
                    value = "> Pet Type: ``"..(_petType or"N/A").."``"..
                           "\n> Remains Queue: ``"..(_remains or"N/A").."``",
                    inline = false
                }}
            }}
        }
        Discord:SendMessage(url, message)
    end

    function m:Leveling(_petName, _petLevel, _remains)
        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        if url == "" then
            return
        end

        local message = {
            content = "",
            embeds = {{
                title = "**EzGarden**",
                type = 'rich',
                color = tonumber("0x00FF00"),
                fields = {{
                    name = '**Profile : ** \n',
                    value = '> Username : ||'..PlayerName.."||",
                    inline = false
                }, {
                    name = "**Pet has reached to level : " ..(_petLevel or"N/A").."**",
                    value = "> Pet Name: ``"..(_petName or"N/A").."``"..
                           "\n> Remains: ``"..(_remains or"N/A").."``",
                    inline = false
                }}
            }}
        }
        Discord:SendMessage(url, message)
    end
    return m
end

-- Module: shop/shop.lua
EmbeddedModules["shop/shop.lua"] = function()
    local m = {}

    local Core

    function m:Init(_core)
        Core = _core
    end

    function m:ConnectToStock(item, buyFunction)
         task.wait(0.1)
        local mainFrame = item:FindFirstChild("Main_Frame")
        if not mainFrame then return end

        local stockText = mainFrame:FindFirstChild("Stock_Text")
        if not stockText then return end

        print("Connecting to stock changes for", item.Name)

        local connection = stockText:GetPropertyChangedSignal("Text"):Connect(function()
            print("Stock changed for", item.Name, "New stock:", stockText.Text)
            local stock = tonumber(stockText.Text:match("%d+"))
            if stock and stock > 0 then
                pcall(buyFunction)
            end
        end)

        return connection
    end

    function m:GetListItems(_shopUI)
        local shopUI = Core:GetPlayerGui():FindFirstChild(_shopUI)
        if not shopUI then
            warn("Shop UI not found")
            return nil
        end

        local Items = shopUI.Frame.ScrollingFrame:GetChildren()
        if not Items then
            warn("Item frame not found in Shop")
            return nil
        end

        local listItems = {}
        for _, item in pairs(Items) do
            if item:FindFirstChild("Main_Frame") then
                table.insert(listItems, item)
            end
        end

        return listItems
    end

    function m:GetItemDetail(_item)
        if not _item then
            warn("Invalid item")
            return nil
        end

        local mainFrame = _item:FindFirstChild("Main_Frame")
        if not mainFrame then
            warn("Main frame not found in item")
            return nil
        end

        local priceText = mainFrame:FindFirstChild("Price_Text")
        if not priceText then
            warn("Price text not found in item")
            return nil
        end

        local stockText = mainFrame:FindFirstChild("Stock_Text")
        if not stockText then
            warn("Stock text not found in item")
            return nil
        end

        local name = _item.Name
        local price = tonumber(priceText.Text:match("%d+"))
        local stock = tonumber(stockText.Text:match("%d+"))

        return {
            Name = name,
            Price = price,
            Stock = stock
        }
    end

    function m:GetUIItem(_shopUI, _itemName)
       local shopUI = Core:GetPlayerGui():FindFirstChild(_shopUI)
        if not shopUI then
            warn("Shop UI not found")
            return nil
        end

        local Item = shopUI:FindFirstChild(_itemName, true)
        if not Item then
            warn("Item frame not found in Shop")
            return nil
        end

        return Item
    end

    function m:GetAvailableItems(_shopUI)
        local availableItems = {}
        if not _shopUI then
            warn("Invalid shop UI")
            return availableItems
        end

        local shopUI = Core:GetPlayerGui():FindFirstChild(_shopUI)
        if not shopUI then
            warn("Shop UI not found")
            return availableItems
        end

        local items = shopUI.Frame.ScrollingFrame:GetChildren()
        if not items then
            warn("No items found in the shop UI")
            return availableItems
        end

        for _, Item in pairs(items) do
            local MainFrame = Item:FindFirstChild("Main_Frame")
            if not MainFrame then continue end

            local StockText = MainFrame.Stock_Text.Text
            local StockCount = tonumber(StockText:match("%d+"))

            availableItems[Item.Name] = StockCount
        end

        return availableItems
    end

    return m
end

-- Module: shop/season_pass.lua
EmbeddedModules["shop/season_pass.lua"] = function()
    local m = {}

    local Window
    local Core

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuySeasonPasses")
        end, function()
            self:BuyAllSeasonPassItems()
        end)
    end

    function m:GetAvailableSeasonPassesItems()
        local availableItems = {}

        local shopUI = Core:GetPlayerGui():FindFirstChild("SeasonPassUI", true)
        if not shopUI then
            return availableItems
        end

        local items = shopUI.SeasonPassFrame.Main.Store.ScrollingFrame.Content:GetChildren()
        for _, Item in pairs(items) do
            local MainFrame = Item:FindFirstChild("Main_Frame")
            if not MainFrame then continue end

            local StockText = MainFrame.Stock_Text.Text
            local StockCount = tonumber(StockText:match("%d+"))

            availableItems[Item.Name] = StockCount
        end

        return availableItems
    end

    function m:BuySeasonPassItem(itemName)
        if not itemName or itemName == "" then
            warn("Invalid item name")
            return
        end

        Core.GameEvents.SeasonPass.BuySeasonPassStock:FireServer(itemName)
    end

    function m:BuyAllSeasonPassItems()
        local items = self:GetAvailableSeasonPassesItems()

        for itemName, stock in pairs(items) do
            if stock < 1 then
                continue
            end

            for i = 1, stock do
                self:BuySeasonPassItem(itemName)
                task.wait(0.1) -- Small delay to avoid spamming
            end
        end
    end

    return m
end

-- Module: shop/traveling.lua
EmbeddedModules["shop/traveling.lua"] = function()
    local m = {}

    local Window
    local Core
    local Shop

    local Connections
    local ShopUI = "TravelingMerchantShop_UI"

    function m:Init(_window, _core, _shop)
        Window = _window
        Core = _core
        Shop = _shop

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuyTravelingMerchant")
        end, function()
            self:BuyAllTravelingItems()
        end)
    end

    function m:BuyTravelingItem(itemName)
        if not itemName or itemName == "" then
            warn("Invalid traveling item name")
            return
        end

        Core.GameEvents.BuyTravelingMerchantShopStock:FireServer(itemName, 5)
    end

    function m:BuyAllTravelingItems()
        local items = Shop:GetAvailableItems(ShopUI)

        for itemName, stock in pairs(items) do
            if stock < 1 then
                continue
            end

            for i = 1, stock do
                self:BuyTravelingItem(itemName)
                task.wait(0.1) -- Small delay to avoid spamming
            end
        end
    end


    return m
end

-- Module: https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua
EmbeddedModules["https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua"] = function()
    -- Bundled Lua Script
    -- Generated by Lua Bundler
    -- https://github.com/alfin-efendy/lua-bundler

    local EmbeddedModules = {}

    -- Module: components/tab
    EmbeddedModules["components/tab"] = function()
        --[[
        	Tab Component
        	EzUI Library - Modular Component

        	Creates a tab with icon, title, and content
        ]]
        -- Component modules (will be loaded by Window)

        local Tab = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator
        local Accordion

        -- Initialize component modules
        function Tab:Init(_colors, _accordion, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Accordion = _accordion
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Tab:Create(config)
        	local tabName = config.Name or config.Title or "New Tab"
        	local tabIcon = config.Icon or nil
        	local tabVisible = config.Visible ~= nil and config.Visible or true
        	local tabCallback = config.Callback or nil
        	local tabScrollFrame = config.TabScrollFrame
        	local tabContents = config.TabContents
        	local scrollFrame = config.ScrollFrame
        	local updateCanvasSize = config.UpdateCanvasSize

        	-- Create tab content frame for this specific tab
        	local tabContent = Instance.new("Frame")
        	tabContent.Size = UDim2.new(1, 0, 1, 0)
        	tabContent.Position = UDim2.new(0, 0, 0, 0)
        	tabContent.BackgroundTransparency = 1
        	tabContent.Visible = false
        	tabContent.ClipsDescendants = false -- Allow SelectBox dropdowns to show
        	tabContent.ZIndex = 2 -- Above scroll frame
        	tabContent.Parent = scrollFrame

        	-- Store tab content in the tabContents table if it exists
        	if tabContents then
        		tabContents[tabName] = tabContent
        	end

        	-- Tab button (container)
        	local tabBtn = Instance.new("TextButton")
        	tabBtn.Size = UDim2.new(1, -10, 0, 36)
        	tabBtn.BackgroundTransparency = 1
        	tabBtn.Text = ""
        	tabBtn.BorderSizePixel = 0
        	tabBtn.ZIndex = 4
        	tabBtn.Visible = tabVisible
        	tabBtn.Parent = tabScrollFrame

        	-- Rounded corners for tab button (only right side)
        	local tabCorner = Instance.new("UICorner")
        	tabCorner.CornerRadius = UDim.new(0, 6)
        	tabCorner.Parent = tabBtn

        	-- Active indicator (left border with rounded right side)
        	local activeIndicator = Instance.new("Frame")
        	activeIndicator.Size = UDim2.new(0, 4, 0, 24)
        	activeIndicator.Position = UDim2.new(0, 0, 0.5, -12)
        	activeIndicator.BackgroundColor3 = Colors.Accent.Primary
        	activeIndicator.BorderSizePixel = 0
        	activeIndicator.ZIndex = 6
        	activeIndicator.Visible = false
        	activeIndicator.Parent = tabBtn

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 4)
        	indicatorCorner.Parent = activeIndicator

        	-- Icon label (left aligned)
        	local iconLabel = Instance.new("TextLabel")
        	iconLabel.Size = UDim2.new(0, 30, 1, 0)
        	iconLabel.Position = UDim2.new(0, 8, 0, 0)
        	iconLabel.BackgroundTransparency = 1
        	iconLabel.Text = tabIcon or ""
        	iconLabel.TextColor3 = Colors.Tab.TextInactive
        	iconLabel.Font = Enum.Font.GothamBold
        	iconLabel.TextSize = 16
        	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
        	iconLabel.ZIndex = 5
        	iconLabel.Parent = tabBtn

        	-- Title label (right aligned)
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = tabName
        	titleLabel.TextColor3 = Colors.Tab.TextInactive
        	titleLabel.Font = Enum.Font.GothamBold
        	titleLabel.TextSize = 14
        	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        	titleLabel.ZIndex = 5
        	titleLabel.Parent = tabBtn

        	-- Function to update title alignment based on icon presence
        	local function updateTitleAlignment()
        		if tabIcon and tabIcon ~= "" then
        			-- Icon on left, title on right
        			titleLabel.Size = UDim2.new(1, -45, 1, 0)
        			titleLabel.Position = UDim2.new(0, 38, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Right
        			iconLabel.Visible = true
        		else
        			-- No icon, title centered
        			titleLabel.Size = UDim2.new(1, -16, 1, 0)
        			titleLabel.Position = UDim2.new(0, 8, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
        			iconLabel.Visible = false
        		end
        	end

        	-- Initial alignment setup
        	updateTitleAlignment()

        	-- Track current Y position for components (reduced top spacing)
        	local currentY = 5

        	-- Helper function to update canvas size after adding components
        	local function updateTabCanvasSize()
        		if updateCanvasSize and tabContent.Visible then
        			-- Only update if this tab is currently active
        			task.spawn(function()
        				task.wait() -- Wait for component to be fully added
        				updateCanvasSize()
        			end)
        		end
        	end

        	-- Tab API
        	local tabAPI = {
        		Button = tabBtn,
        		Content = tabContent,
        		Name = tabName,
        	}

        	function tabAPI:SetIcon(newIcon)
        		tabIcon = newIcon
        		iconLabel.Text = newIcon or ""
        		updateTitleAlignment()
        	end

        	function tabAPI:SetTitle(newTitle)
        		tabName = newTitle
        		titleLabel.Text = newTitle
        	end

        	function tabAPI:SetVisible(visible)
        		tabBtn.Visible = visible
        	end

        	function tabAPI:Show()
        		tabContent.Visible = true
        	end

        	function tabAPI:Hide()
        		tabContent.Visible = false
        	end

        	function tabAPI:IsVisible()
        		return tabContent.Visible
        	end

        	function tabAPI:Select()
        		tabContent.Visible = true
        		tabBtn.BackgroundTransparency = 0
        		tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		activeIndicator.Visible = true
        		titleLabel.TextColor3 = Colors.Text.Primary
        		iconLabel.TextColor3 = Colors.Text.Primary

        		-- Update canvas size when tab becomes active
        		if updateCanvasSize then
        			-- Wait a frame to ensure visibility changes are processed
        			task.spawn(function()
        				task.wait()
        				updateCanvasSize()
        			end)
        		end

        		if tabCallback then
        			tabCallback()
        		end
        	end

        	function tabAPI:Deselect()
        		tabContent.Visible = false
        		tabBtn.BackgroundTransparency = 1
        		activeIndicator.Visible = false
        		titleLabel.TextColor3 = Colors.Tab.TextInactive
        		iconLabel.TextColor3 = Colors.Tab.TextInactive
        	end

        	-- Hover effects
        	tabBtn.MouseEnter:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundHover
        		end
        	end)

        	tabBtn.MouseLeave:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 1
        		else
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		end
        	end)

        	-- Add Button Component
        	function tabAPI:AddButton(buttonConfig)
        		if not Button then
        			return nil
        		end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = tabContent
        		btnConfig.Y = currentY
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return buttonAPI
        	end

        	-- Add Toggle Component
        	function tabAPI:AddToggle(toggleConfig)
        		if not Toggle then
        			return nil
        		end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = tabContent
        		toggleConfig.Y = currentY
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return toggleAPI
        	end

        	-- Add TextBox Component
        	function tabAPI:AddTextBox(textboxConfig)
        		if not TextBox then
        			return nil
        		end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = tabContent
        		textboxConfig.Y = currentY
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)

        		-- Calculate height based on TextBox configuration
        		local hasTitle = (textboxConfig.Name and textboxConfig.Name ~= "") or (textboxConfig.Title and textboxConfig.Title ~= "")
        		local multiline = textboxConfig.Multiline or false
        		local labelHeight = hasTitle and 18 or 0
        		local inputHeight = multiline and 80 or 30
        		local spacing = hasTitle and 2 or 0
        		local totalHeight = labelHeight + inputHeight + spacing + 5 -- +5 for component spacing

        		currentY = currentY + totalHeight
        		updateTabCanvasSize()

        		return textboxAPI
        	end

        	-- Add NumberBox Component
        	function tabAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then
        			return nil
        		end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = tabContent
        		numberboxConfig.Y = currentY
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return numberboxAPI
        	end

        	-- Add SelectBox Component
        	function tabAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then
        			return nil
        		end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = tabContent
        		selectboxConfig.Y = currentY
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		currentY = currentY + 30
        		updateTabCanvasSize()

        		return selectboxAPI
        	end

        	-- Add Label Component
        	function tabAPI:AddLabel(labelConfig)
        		if not Label then
        			return nil
        		end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = tabContent
        		lblConfig.Y = currentY
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		currentY = currentY + 25
        		updateTabCanvasSize()

        		return labelAPI
        	end

        	-- Add Separator Component
        	function tabAPI:AddSeparator(separatorConfig)
        		if not Separator then
        			return nil
        		end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = tabContent
        		separatorConfig.Y = currentY

        		local separatorAPI = Separator:Create(separatorConfig)
        		currentY = currentY + 15
        		updateTabCanvasSize()

        		return separatorAPI
        	end

        	-- Add Accordion Component (USING MODULAR ACCORDION)
        	function tabAPI:AddAccordion(accordionConfig)
        		if not Accordion then
        			return nil
        		end

        		accordionConfig = accordionConfig or {}

        		-- Set parent and position
        		accordionConfig.Parent = tabContent
        		accordionConfig.Y = currentY

        		-- Pass through EzUI config
        		accordionConfig.EzUI = config.EzUI
        		accordionConfig.SaveConfiguration = config.SaveConfiguration
        		accordionConfig.RegisterComponent = config.RegisterComponent
        		accordionConfig.Settings= config.Settings
        		accordionConfig.ScreenGui = config.ScreenGui

        		-- Pass callback for height changes
        		accordionConfig.OnHeightChanged = function()
        			-- Recalculate tab height
        			local maxY = 10

        			for _, child in pairs(tabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childBottom = child.Position.Y.Offset + child.AbsoluteSize.Y
        					maxY = math.max(maxY, childBottom)
        				end
        			end

        			-- Update currentY (reduced spacing)
        			currentY = maxY + 5

        			-- Use our unified canvas update function
        			updateTabCanvasSize()
        		end

        		-- Create accordion using module
        		local accordionAPI = Accordion:Create(accordionConfig)

        		-- Update currentY for next component based on actual container size (reduced spacing)
        		task.wait() -- Ensure size is rendered
        		local actualHeight = accordionAPI.Container.AbsoluteSize.Y
        		currentY = currentY + actualHeight + 5
        		updateTabCanvasSize()

        		return accordionAPI
        	end

        	return tabAPI
        end

        return Tab

    end

    -- Module: components/numberbox
    EmbeddedModules["components/numberbox"] = function()
        --[[
        	NumberBox Component
        	EzUI Library - Modular Component

        	Creates a numeric input field with increment/decrement buttons
        ]]
        local NumberBox = {}

        local Colors

        function NumberBox:Init(_colors)
        	Colors = _colors
        end

        function NumberBox:Create(config)
        	local placeholder = config.Placeholder or "Enter number..."
        	local defaultValue = config.Default or 0
        	local callback = config.Callback or function() end
        	local minValue = config.Min or -math.huge
        	local maxValue = config.Max or math.huge
        	local increment = config.Increment or 1
        	local decimals = config.Decimals or 0
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- NumberBox state
        	local currentValue = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			currentValue = flagValue
        			defaultValue = currentValue
        		end
        	end

        	-- Main numberbox container
        	local numberBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		numberBoxContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion numberboxes - let UIListLayout handle it
        		numberBoxContainer.ZIndex = 6
        	else
        		numberBoxContainer.Size = UDim2.new(1, -20, 0, 30)
        		numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		numberBoxContainer.ZIndex = 3
        		numberBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	numberBoxContainer.BackgroundTransparency = 1
        	numberBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	numberBoxContainer.Parent = parentContainer

        	-- Number input box
        	local numberBox = Instance.new("TextBox")
        	if isForAccordion then
        		numberBox.Size = UDim2.new(1, -45, 1, 0)
        		numberBox.TextSize = 12
        		numberBox.ZIndex = 7
        	else
        		numberBox.Size = UDim2.new(1, -60, 1, 0)
        		numberBox.TextSize = 14
        		numberBox.ZIndex = 4
        	end
        	numberBox.Position = UDim2.new(0, 0, 0, 0)
        	numberBox.BackgroundColor3 = Colors.Input.Background
        	numberBox.BorderColor3 = Colors.Input.Border
        	numberBox.BorderSizePixel = 1
        	numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
        	numberBox.PlaceholderText = placeholder
        	numberBox.TextColor3 = Colors.Input.Text
        	numberBox.PlaceholderColor3 = Colors.Input.Placeholder
        	numberBox.Font = Enum.Font.SourceSans
        	numberBox.TextXAlignment = Enum.TextXAlignment.Center
        	numberBox.TextYAlignment = Enum.TextYAlignment.Center
        	numberBox.TextScaled = false -- Prevent text from scaling down automatically
        	numberBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	numberBox.ClearTextOnFocus = false
        	numberBox.Parent = numberBoxContainer

        	-- Add padding to NumberBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.Parent = numberBox

        	-- Round corners for number box
        	local numberCorner = Instance.new("UICorner")
        	numberCorner.CornerRadius = UDim.new(0, 4)
        	numberCorner.Parent = numberBox

        	-- Increment button (up arrow)
        	local incrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		incrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		incrementBtn.Position = UDim2.new(1, -22, 0, 1)
        		incrementBtn.TextSize = 8
        		incrementBtn.ZIndex = 7
        	else
        		incrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		incrementBtn.Position = UDim2.new(1, -30, 0, 1)
        		incrementBtn.TextSize = 10
        		incrementBtn.ZIndex = 4
        	end
        	incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	incrementBtn.BorderColor3 = Colors.Border.Default
        	incrementBtn.BorderSizePixel = 1
        	incrementBtn.Text = "▲"
        	incrementBtn.TextColor3 = Colors.Text.Secondary
        	incrementBtn.Font = Enum.Font.SourceSans
        	incrementBtn.Parent = numberBoxContainer

        	-- Decrement button (down arrow)
        	local decrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		decrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		decrementBtn.Position = UDim2.new(1, -22, 0, 13)
        		decrementBtn.TextSize = 8
        		decrementBtn.ZIndex = 7
        	else
        		decrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		decrementBtn.Position = UDim2.new(1, -30, 0, 15)
        		decrementBtn.TextSize = 10
        		decrementBtn.ZIndex = 4
        	end
        	decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	decrementBtn.BorderColor3 = Colors.Border.Default
        	decrementBtn.BorderSizePixel = 1
        	decrementBtn.Text = "▼"
        	decrementBtn.TextColor3 = Colors.Text.Secondary
        	decrementBtn.Font = Enum.Font.SourceSans
        	decrementBtn.Parent = numberBoxContainer

        	-- Function to validate and update value
        	local function updateValue(newValue)
        		-- Clamp to min/max
        		newValue = math.max(minValue, math.min(maxValue, newValue))

        		-- Round to decimal places
        		if decimals > 0 then
        			local multiplier = 10 ^ decimals
        			newValue = math.floor(newValue * multiplier + 0.5) / multiplier
        		else
        			newValue = math.floor(newValue + 0.5)
        		end

        		currentValue = newValue

        		-- Update text box display
        		if decimals > 0 then
        			numberBox.Text = string.format("%." .. decimals .. "f", newValue)
        		else
        			numberBox.Text = tostring(newValue)
        		end

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentValue)
        		end
        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(currentValue)
        		end)

        		if not success then
        		end

        		return newValue
        	end 

        	-- Text change handler with validation
        	numberBox.FocusLost:Connect(function()
        		local inputText = numberBox.Text
        		local numValue = tonumber(inputText)

        		if numValue then
        			updateValue(numValue)
        		else
        			-- Invalid input, revert to current value
        			if decimals > 0 then
        				numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
        			else
        				numberBox.Text = tostring(currentValue)
        			end
        		end
        	end)

        	-- Increment button handler
        	incrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue + increment)
        	end)

        	-- Decrement button handler
        	decrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue - increment)
        	end)

        	-- Button hover effects
        	incrementBtn.MouseEnter:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	incrementBtn.MouseLeave:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	decrementBtn.MouseEnter:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	decrementBtn.MouseLeave:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Focus effects
        	numberBox.Focused:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	numberBox.FocusLost:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return NumberBox API
        	local numberBoxAPI = {
        		NumberBox = numberBoxContainer
        	}

        	function numberBoxAPI:GetValue()
        		return currentValue
        	end

        	function numberBoxAPI:SetValue(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		else
        		end
        	end

        	function numberBoxAPI:SetMin(newMin)
        		minValue = tonumber(newMin) or -math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetMax(newMax)
        		maxValue = tonumber(newMax) or math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetIncrement(newIncrement)
        		increment = tonumber(newIncrement) or 1
        	end

        	function numberBoxAPI:Clear()
        		updateValue(0)
        	end

        	function numberBoxAPI:Focus()
        		numberBox:CaptureFocus()
        	end

        	function numberBoxAPI:Blur()
        		numberBox:ReleaseFocus()
        	end

        	function numberBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function numberBoxAPI:Set(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, numberBoxAPI)
        	end

        	return numberBoxAPI
        end

        return NumberBox

    end

    -- Module: components/notification
    EmbeddedModules["components/notification"] = function()
        --[[
        	Notification Component (Sonner-style)
        	EzUI Library - Modular Component

        	Creates toast notifications with stacking, animations, and different types
        	Similar to Sonner from shadcn/ui
        ]]

        local Notification = {}

        local Colors
        local TweenService = game:GetService("TweenService")

        -- Global notification container and state
        local NotificationContainer = nil
        local ActiveNotifications = {}
        local NotificationId = 0
        local MaxNotifications = 5
        local NotificationWidth = 300  -- Reduced from 350
        local NotificationHeight = 55  -- Reduced from 70
        local StackOffset = 6          -- Reduced from 8
        local AnimationDuration = 0.3

        function Notification:Init(_colors)
        	Colors = _colors
        end

        -- Initialize the global notification container
        local function initializeContainer(screenGui)
        	if NotificationContainer then return end

        	NotificationContainer = Instance.new("Frame")
        	NotificationContainer.Name = "NotificationContainer"
        	NotificationContainer.Size = UDim2.new(0, NotificationWidth + 20, 1, 0)
        	NotificationContainer.Position = UDim2.new(1, -NotificationWidth - 30, 0, 0) -- Top right
        	NotificationContainer.BackgroundTransparency = 1
        	NotificationContainer.ZIndex = 1000
        	NotificationContainer.Parent = screenGui
        end

        -- Create individual notification
        local function createNotification(config)
        	local notificationType = config.Type or "info" -- info, success, warning, error
        	local title = config.Title or ""
        	local message = config.Message or config.Description or ""
        	local duration = config.Duration or 4000 -- milliseconds
        	local action = config.Action -- {label, callback}
        	local onDismiss = config.OnDismiss

        	-- Generate unique ID
        	NotificationId = NotificationId + 1
        	local id = NotificationId

        	-- Create notification frame
        	local notification = Instance.new("Frame")
        	notification.Name = "Notification_" .. id
        	notification.Size = UDim2.new(0, NotificationWidth, 0, NotificationHeight)
        	notification.Position = UDim2.new(0, 10, 0, 20) -- Start position
        	notification.BackgroundColor3 = Colors.Surface.Elevated
        	notification.BorderSizePixel = 0
        	notification.ZIndex = 1001
        	notification.ClipsDescendants = false
        	notification.Parent = NotificationContainer

        	-- Notification corner radius
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 8)
        	corner.Parent = notification

        	-- Notification border/stroke
        	local stroke = Instance.new("UIStroke")
        	stroke.Thickness = 1
        	stroke.Transparency = 0.8

        	-- Type-specific colors
        	if notificationType == "success" then
        		stroke.Color = Colors.Status.Success
        	elseif notificationType == "warning" then
        		stroke.Color = Colors.Status.Warning
        	elseif notificationType == "error" then
        		stroke.Color = Colors.Status.Error
        	else -- info
        		stroke.Color = Colors.Border.Default
        	end
        	stroke.Parent = notification

        	-- Subtle shadow effect
        	local shadow = Instance.new("Frame")
        	shadow.Size = UDim2.new(1, 4, 1, 4)
        	shadow.Position = UDim2.new(0, -2, 0, 2)
        	shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	shadow.BackgroundTransparency = 0.9
        	shadow.ZIndex = notification.ZIndex - 1
        	shadow.Parent = notification

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 10)
        	shadowCorner.Parent = shadow

        	-- Status indicator (colored bar)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 4, 1, -12)
        	indicator.Position = UDim2.new(0, 6, 0, 6)
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = notification.ZIndex + 1
        	indicator.Parent = notification

        	if notificationType == "success" then
        		indicator.BackgroundColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		indicator.BackgroundColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		indicator.BackgroundColor3 = Colors.Status.Error
        	else -- info
        		indicator.BackgroundColor3 = Colors.Accent.Primary
        	end

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 2)
        	indicatorCorner.Parent = indicator

        	-- Icon (emoji-based for simplicity, more compact)
        	local icon = Instance.new("TextLabel")
        	icon.Size = UDim2.new(0, 16, 0, 16)  -- Reduced from 20x20
        	icon.Position = UDim2.new(0, 16, 0, 8)  -- Closer to edges
        	icon.BackgroundTransparency = 1
        	icon.Font = Enum.Font.GothamBold  -- Use bold for better icon visibility
        	icon.TextSize = 14  -- Reduced from 16
        	icon.TextColor3 = Colors.Text.Primary
        	icon.TextXAlignment = Enum.TextXAlignment.Center
        	icon.TextYAlignment = Enum.TextYAlignment.Center
        	icon.ZIndex = notification.ZIndex + 1
        	icon.Parent = notification

        	if notificationType == "success" then
        		icon.Text = "✓"
        		icon.TextColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		icon.Text = "⚠"
        		icon.TextColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		icon.Text = "!"  -- Changed to exclamation mark for better visibility
        		icon.TextColor3 = Colors.Status.Error
        		icon.TextSize = 16  -- Slightly larger for error icon
        	else -- info
        		icon.Text = "i"  -- Changed to simple 'i' for info
        		icon.TextColor3 = Colors.Accent.Primary
        	end

        	-- Content container (more compact)
        	local contentContainer = Instance.new("Frame")
        	contentContainer.Size = UDim2.new(1, action and -80 or -50, 1, -8)  -- Reduced margins
        	contentContainer.Position = UDim2.new(0, 40, 0, 4)  -- Closer positioning
        	contentContainer.BackgroundTransparency = 1
        	contentContainer.ZIndex = notification.ZIndex + 1
        	contentContainer.Parent = notification

        	-- Title (more compact)
        	local hasTitle = title and title ~= ""
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, 16)  -- Reduced from 18
        		titleLabel.Position = UDim2.new(0, 0, 0, 1)  -- Reduced from 2
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = title
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.TextYAlignment = Enum.TextYAlignment.Top
        		titleLabel.Font = Enum.Font.GothamBold
        		titleLabel.TextSize = 13  -- Reduced from 14
        		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        		titleLabel.ZIndex = contentContainer.ZIndex + 1
        		titleLabel.Parent = contentContainer
        	end

        	-- Message (more compact)
        	if message and message ~= "" then
        		local messageLabel = Instance.new("TextLabel")
        		messageLabel.Size = UDim2.new(1, 0, hasTitle and 0, 14 or 1, 0)  -- Reduced from 16
        		messageLabel.Position = UDim2.new(0, 0, hasTitle and 0, 17 or 0, 0)  -- Reduced from 20
        		messageLabel.BackgroundTransparency = 1
        		messageLabel.Text = message
        		messageLabel.TextColor3 = Colors.Text.Secondary
        		messageLabel.TextXAlignment = Enum.TextXAlignment.Left
        		messageLabel.TextYAlignment = hasTitle and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        		messageLabel.Font = Enum.Font.Gotham
        		messageLabel.TextSize = 11  -- Reduced from 12
        		messageLabel.TextWrapped = true
        		messageLabel.ZIndex = contentContainer.ZIndex + 1
        		messageLabel.Parent = contentContainer
        	end

        	-- Action button (more compact)
        	if action then
        		local actionButton = Instance.new("TextButton")
        		actionButton.Size = UDim2.new(0, 50, 0, 20)  -- Reduced from 60x24
        		actionButton.Position = UDim2.new(1, -55, 0.5, -10)  -- Adjusted position
        		actionButton.BackgroundColor3 = Colors.Button.Primary
        		actionButton.BorderSizePixel = 0
        		actionButton.Text = action.label or "Action"
        		actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        		actionButton.Font = Enum.Font.Gotham
        		actionButton.TextSize = 10  -- Reduced from 11
        		actionButton.ZIndex = notification.ZIndex + 2
        		actionButton.Parent = notification

        		local actionCorner = Instance.new("UICorner")
        		actionCorner.CornerRadius = UDim.new(0, 4)
        		actionCorner.Parent = actionButton

        		-- Action button hover
        		actionButton.MouseEnter:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.PrimaryHover
        			})
        			tween:Play()
        		end)

        		actionButton.MouseLeave:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.Primary
        			})
        			tween:Play()
        		end)

        		actionButton.MouseButton1Click:Connect(function()
        			if action.callback then
        				action.callback()
        			end
        			Notification:Dismiss(id)
        		end)
        	end

        	-- Close button (moved to top-right corner)
        	local closeButton = Instance.new("TextButton")
        	closeButton.Size = UDim2.new(0, 20, 0, 20)
        	closeButton.Position = UDim2.new(1, -24, 0, 0)  -- Moved even closer to top edge
        	closeButton.BackgroundTransparency = 1
        	closeButton.Text = "×"
        	closeButton.TextColor3 = Colors.Text.Secondary
        	closeButton.TextSize = 16
        	closeButton.Font = Enum.Font.GothamBold
        	closeButton.ZIndex = notification.ZIndex + 2
        	closeButton.Parent = notification

        	-- Close button hover
        	closeButton.MouseEnter:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Primary
        		closeButton.BackgroundTransparency = 0.9
        		closeButton.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	closeButton.MouseLeave:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Secondary
        		closeButton.BackgroundTransparency = 1
        	end)

        	closeButton.MouseButton1Click:Connect(function()
        		Notification:Dismiss(id)
        	end)

        	-- Progress bar (for duration, more compact)
        	local progressBar = Instance.new("Frame")
        	progressBar.Size = UDim2.new(1, -8, 0, 2)  -- Slightly wider (reduced margin from 12 to 8)
        	progressBar.Position = UDim2.new(0, 4, 1, -6)  -- Adjusted position (closer to bottom edge)
        	progressBar.BackgroundColor3 = indicator.BackgroundColor3
        	progressBar.BackgroundTransparency = 0.7
        	progressBar.BorderSizePixel = 0
        	progressBar.ZIndex = notification.ZIndex + 1
        	progressBar.Parent = notification

        	local progressCorner = Instance.new("UICorner")
        	progressCorner.CornerRadius = UDim.new(0, 1)
        	progressCorner.Parent = progressBar

        	-- Store notification data
        	local notificationData = {
        		id = id,
        		frame = notification,
        		duration = duration,
        		onDismiss = onDismiss,
        		startTime = tick() * 1000,
        		progressBar = progressBar
        	}

        	table.insert(ActiveNotifications, notificationData)

        	-- Calculate proper position for this notification
        	local notificationIndex = #ActiveNotifications
        	local yOffset = 20 + ((notificationIndex - 1) * (NotificationHeight + StackOffset))

        	-- Animate in from off-screen to proper stacked position
        	notification.Position = UDim2.new(1, 0, 0, yOffset) -- Start off-screen at correct Y
        	local slideIn = TweenService:Create(notification, 
        		TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        		{Position = UDim2.new(0, 10, 0, yOffset)}
        	)
        	slideIn:Play()

        	-- Update positions for all other notifications (to apply stacking effects)
        	updateNotificationPositions()

        	-- Auto dismiss after duration
        	if duration > 0 then
        		task.spawn(function()
        			local startTime = tick() * 1000
        			while true do
        				task.wait(0.1)
        				local elapsed = (tick() * 1000) - startTime
        				local progress = elapsed / duration

        				if progress >= 1 then
        					Notification:Dismiss(id)
        					break
        				end

        				-- Update progress bar
        				progressBar.Size = UDim2.new(1 - progress, -12, 0, 2)
        			end
        		end)
        	end

        	-- Remove old notifications if exceeding max
        	if #ActiveNotifications > MaxNotifications then
        		Notification:Dismiss(ActiveNotifications[1].id)
        	end

        	return id
        end

        -- Update notification positions with stacking effect
        function updateNotificationPositions()
        	for i, notificationData in ipairs(ActiveNotifications) do
        		local yOffset = 20 + ((i - 1) * (NotificationHeight + StackOffset))
        		local scale = math.max(0.95, 1 - ((i - 1) * 0.02)) -- Slight scale reduction for stacked items
        		local transparency = math.min(0.3, (i - 1) * 0.1) -- Slight transparency for stacked items

        		local tween = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{
        				Position = UDim2.new(0, 10, 0, yOffset),
        				Size = UDim2.new(0, NotificationWidth * scale, 0, NotificationHeight * scale)
        			}
        		)
        		tween:Play()

        		-- Apply transparency to stacked notifications
        		if i > 1 then
        			notificationData.frame.BackgroundTransparency = transparency
        		else
        			notificationData.frame.BackgroundTransparency = 0
        		end
        	end
        end

        -- Public API
        function Notification:Create(config)
        	if not config then
        		return nil
        	end

        	-- Initialize container if needed
        	local screenGui = config.ScreenGui or game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChildOfClass("ScreenGui")
        	initializeContainer(screenGui)

        	return createNotification(config)
        end

        -- Dismiss notification by ID
        function Notification:Dismiss(id)
        	for i, notificationData in ipairs(ActiveNotifications) do
        		if notificationData.id == id then
        			-- Animate out
        			local slideOut = TweenService:Create(notificationData.frame,
        				TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        			)

        			slideOut:Play()
        			slideOut.Completed:Connect(function()
        				notificationData.frame:Destroy()
        			end)

        			-- Call dismiss callback
        			if notificationData.onDismiss then
        				notificationData.onDismiss()
        			end

        			-- Remove from active notifications
        			table.remove(ActiveNotifications, i)

        			-- Update positions
        			updateNotificationPositions()
        			break
        		end
        	end
        end

        -- Clear all notifications
        function Notification:Clear()
        	for _, notificationData in ipairs(ActiveNotifications) do
        		local slideOut = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        		)
        		slideOut:Play()
        		slideOut.Completed:Connect(function()
        			notificationData.frame:Destroy()
        		end)
        	end
        	ActiveNotifications = {}
        end

        -- Convenience methods for different types
        function Notification:Success(config)
        	config = config or {}
        	config.Type = "success"
        	return self:Create(config)
        end

        function Notification:Warning(config)
        	config = config or {}
        	config.Type = "warning"
        	return self:Create(config)
        end

        function Notification:Error(config)
        	config = config or {}
        	config.Type = "error"
        	return self:Create(config)
        end

        function Notification:Info(config)
        	config = config or {}
        	config.Type = "info"
        	return self:Create(config)
        end

        return Notification
    end

    -- Module: components/selectbox
    EmbeddedModules["components/selectbox"] = function()
        --[[
        local Colors = require(game.ReplicatedStorage.utils.colors)
        	SelectBox Component
        	EzUI Library - Modular Component

        	Creates a dropdown select box with search and multi-select support
        	Note: This is a simplified modular version. For full features, use the main UI library.
        ]]
        local SelectBox = {}

        local Colors

        function SelectBox:Init(_colors)
        	Colors = _colors
        end

        function SelectBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
        	local placeholder = config.Placeholder or "Select option..."
        	local multiSelect = config.MultiSelect or false
        	local callback = config.Callback or function() end
        	local onDropdownOpen = config.OnDropdownOpen or function() end
        	local onInit = config.OnInit or function() end
        	local bottomSheetMaxHeight = config.BottomSheetHeight or config.MaxHeight or 320
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local screenGui = config.ScreenGui
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Normalize options to {text, value} format
        	local options = {}
        	for i, option in ipairs(rawOptions) do
        		if type(option) == "string" then
        			table.insert(options, {text = option, value = option})
        		elseif type(option) == "table" and option.text and option.value then
        			table.insert(options, option)
        		end
        	end

        	local selectedValues = {}
        	local isOpen = false

        	-- Title configuration
        	local hasTitle = name and name ~= ""
        	local labelHeight = isForAccordion and 16 or 18
        	local selectHeight = isForAccordion and 25 or 30
        	local totalHeight = hasTitle and (labelHeight + selectHeight + 2) or selectHeight

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			if type(flagValue) == "table" then
        				selectedValues = flagValue
        			elseif flagValue ~= "" then
        				selectedValues = {flagValue}
        			end
        		end
        	end

        	-- Main container
        	local selectContainer = Instance.new("Frame")
        	if isForAccordion then
        		selectContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		-- Don't set Position for accordion selectboxes - let UIListLayout handle it
        		selectContainer.ZIndex = 6
        	else
        		selectContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		selectContainer.Position = UDim2.new(0, 10, 0, currentY)
        		selectContainer.ZIndex = 3
        		selectContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	selectContainer.BackgroundTransparency = 1
        	selectContainer.ClipsDescendants = false
        	selectContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = selectContainer
        	end

        	-- Select button (modern design)
        	local selectButton = Instance.new("TextButton")
        	if hasTitle then
        		selectButton.Size = UDim2.new(1, 0, 0, selectHeight)
        		selectButton.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		selectButton.Size = UDim2.new(1, 0, 1, 0)
        		selectButton.Position = UDim2.new(0, 0, 0, 0)
        	end
        	selectButton.BackgroundColor3 = Colors.Input.Background
        	selectButton.BorderSizePixel = 0
        	selectButton.Text = "  " .. placeholder
        	selectButton.TextColor3 = Colors.Text.Secondary
        	selectButton.TextXAlignment = Enum.TextXAlignment.Left
        	selectButton.Font = Enum.Font.Gotham
        	selectButton.TextSize = isForAccordion and 12 or 14
        	selectButton.TextScaled = false
        	selectButton.ClipsDescendants = true
        	selectButton.ZIndex = isForAccordion and 7 or 4
        	selectButton.Parent = selectContainer

        	-- Chips container for multi-select (scrollable, tighter spacing)
        	local chipsContainer = Instance.new("ScrollingFrame")
        	chipsContainer.Size = UDim2.new(1, -24, 1, -2) -- Reduced gap to arrow
        	chipsContainer.Position = UDim2.new(0, 8, 0, 1)
        	chipsContainer.BackgroundTransparency = 1
        	chipsContainer.BorderSizePixel = 0
        	chipsContainer.ClipsDescendants = true
        	chipsContainer.ScrollBarThickness = 0 -- Hide scrollbar for cleaner look
        	chipsContainer.ScrollingDirection = Enum.ScrollingDirection.X -- Horizontal scroll
        	chipsContainer.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be auto-calculated
        	chipsContainer.ZIndex = selectButton.ZIndex + 1
        	chipsContainer.Parent = selectButton
        	chipsContainer.Visible = false -- Initially hidden

        	-- Chips layout
        	local chipsLayout = Instance.new("UIListLayout")
        	chipsLayout.FillDirection = Enum.FillDirection.Horizontal
        	chipsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        	chipsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        	chipsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	chipsLayout.Padding = UDim.new(0, 4)
        	chipsLayout.Wraps = false -- No wrapping since we're scrolling horizontally
        	chipsLayout.Parent = chipsContainer

        	-- Modern rounded corners
        	local selectCorner = Instance.new("UICorner")
        	selectCorner.CornerRadius = UDim.new(0, 8)
        	selectCorner.Parent = selectButton

        	-- Subtle border effect
        	local selectStroke = Instance.new("UIStroke")
        	selectStroke.Color = Colors.Input.Border
        	selectStroke.Thickness = 1
        	selectStroke.Parent = selectButton

        	-- Padding for better text spacing (further reduced right padding)
        	local selectPadding = Instance.new("UIPadding")
        	selectPadding.PaddingLeft = UDim.new(0, 8)
        	selectPadding.PaddingRight = UDim.new(0, 24)
        	selectPadding.PaddingTop = UDim.new(0, 1)
        	selectPadding.PaddingBottom = UDim.new(0, 1)
        	selectPadding.Parent = selectButton

        	-- Modern arrow icon (embedded in select button, tighter positioning)
        	local arrow = Instance.new("TextLabel")
        	if hasTitle then
        		arrow.Size = UDim2.new(0, 20, 0, selectHeight)
        		arrow.Position = UDim2.new(1, -20, 0, labelHeight + 2)
        	else
        		arrow.Size = UDim2.new(0, 20, 1, 0)
        		arrow.Position = UDim2.new(1, -20, 0, 0)
        	end
        	arrow.BackgroundTransparency = 1
        	arrow.Text = "▼"
        	arrow.TextColor3 = Colors.Text.Secondary
        	arrow.TextXAlignment = Enum.TextXAlignment.Center
        	arrow.TextYAlignment = Enum.TextYAlignment.Center
        	arrow.Font = Enum.Font.GothamBold
        	arrow.TextSize = isForAccordion and 14 or 16
        	arrow.ZIndex = isForAccordion and 8 or 5
        	arrow.Parent = selectContainer

        	-- Find the window frame container
        	local windowFrame = screenGui and screenGui:FindFirstChild("Frame") or selectContainer.Parent
        	while windowFrame and not (windowFrame.Name:find("Frame") and windowFrame.Parent == screenGui) do
        		windowFrame = windowFrame.Parent
        		if windowFrame == screenGui or not windowFrame then
        			windowFrame = screenGui:FindFirstChildOfClass("Frame")
        			break
        		end
        	end

        	-- Bottom sheet overlay (TextButton for click detection)
        	local bottomSheetOverlay = Instance.new("TextButton")
        	bottomSheetOverlay.Size = UDim2.new(1, 0, 1, 0)
        	bottomSheetOverlay.Position = UDim2.new(0, 0, 0, 0)
        	bottomSheetOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	bottomSheetOverlay.BackgroundTransparency = 0.5
        	bottomSheetOverlay.BorderSizePixel = 0
        	bottomSheetOverlay.Text = ""
        	bottomSheetOverlay.Visible = false
        	bottomSheetOverlay.ZIndex = 100
        	bottomSheetOverlay.Parent = windowFrame or screenGui or selectContainer.Parent

        	-- Bottom sheet container (customizable height)
        	local bottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        	local bottomSheet = Instance.new("Frame")
        	bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        	bottomSheet.Position = UDim2.new(0, 20, 1, 0) -- Start below window
        	bottomSheet.BackgroundColor3 = Colors.Surface.Default
        	bottomSheet.BorderSizePixel = 0
        	bottomSheet.ZIndex = 101
        	bottomSheet.Parent = bottomSheetOverlay

        	-- Modern rounded corners for bottom sheet
        	local bottomSheetCorner = Instance.new("UICorner")
        	bottomSheetCorner.CornerRadius = UDim.new(0, 12)
        	bottomSheetCorner.Parent = bottomSheet

        	-- Handle bar at top of bottom sheet (smaller)
        	local handleBar = Instance.new("Frame")
        	handleBar.Size = UDim2.new(0, 32, 0, 3)
        	handleBar.Position = UDim2.new(0.5, -16, 0, 6)
        	handleBar.BackgroundColor3 = Colors.Text.Secondary
        	handleBar.BorderSizePixel = 0
        	handleBar.ZIndex = 102
        	handleBar.Parent = bottomSheet

        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 1.5)
        	handleCorner.Parent = handleBar

        	-- Title for bottom sheet (smaller)
        	local sheetTitle = Instance.new("TextLabel")
        	sheetTitle.Size = UDim2.new(1, -32, 0, 24)
        	sheetTitle.Position = UDim2.new(0, 16, 0, 16)
        	sheetTitle.BackgroundTransparency = 1
        	sheetTitle.Text = name ~= "" and name or "Select Option"
        	sheetTitle.TextColor3 = Colors.Text.Primary
        	sheetTitle.TextXAlignment = Enum.TextXAlignment.Left
        	sheetTitle.TextYAlignment = Enum.TextYAlignment.Center
        	sheetTitle.Font = Enum.Font.GothamBold
        	sheetTitle.TextSize = 16
        	sheetTitle.ZIndex = 102
        	sheetTitle.Parent = bottomSheet

        	-- Modern search box (smaller)
        	local searchBox = Instance.new("TextBox")
        	searchBox.Size = UDim2.new(1, -32, 0, 32)
        	searchBox.Position = UDim2.new(0, 16, 0, 48)
        	searchBox.BackgroundColor3 = Colors.Input.Background
        	searchBox.BorderSizePixel = 0
        	searchBox.PlaceholderText = "🔍 Search options..."
        	searchBox.Text = ""
        	searchBox.TextColor3 = Colors.Text.Primary
        	searchBox.Font = Enum.Font.Gotham
        	searchBox.TextSize = 13
        	searchBox.TextXAlignment = Enum.TextXAlignment.Left
        	searchBox.ZIndex = 102
        	searchBox.Parent = bottomSheet

        	-- Search box styling
        	local searchCorner = Instance.new("UICorner")
        	searchCorner.CornerRadius = UDim.new(0, 6)
        	searchCorner.Parent = searchBox

        	local searchPadding = Instance.new("UIPadding")
        	searchPadding.PaddingLeft = UDim.new(0, 12)
        	searchPadding.PaddingRight = UDim.new(0, 12)
        	searchPadding.Parent = searchBox

        	-- Options container (scrollable, smaller)
        	local optionsScrollFrame = Instance.new("ScrollingFrame")
        	optionsScrollFrame.Size = UDim2.new(1, -32, 1, -96)
        	optionsScrollFrame.Position = UDim2.new(0, 16, 0, 88)
        	optionsScrollFrame.BackgroundTransparency = 1
        	optionsScrollFrame.BorderSizePixel = 0
        	optionsScrollFrame.ScrollBarThickness = 4
        	optionsScrollFrame.ScrollBarImageColor3 = Colors.Accent.Primary
        	optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	optionsScrollFrame.ZIndex = 102
        	optionsScrollFrame.Parent = bottomSheet

        	local optionsContainer = Instance.new("Frame")
        	optionsContainer.Size = UDim2.new(1, 0, 0, 0) -- Auto-size based on content
        	optionsContainer.Position = UDim2.new(0, 0, 0, 0)
        	optionsContainer.BackgroundTransparency = 1
        	optionsContainer.ZIndex = 103
        	optionsContainer.Parent = optionsScrollFrame

        	-- List layout
        	local listLayout = Instance.new("UIListLayout")
        	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	listLayout.Parent = optionsContainer

        	-- Forward declarations
        	local updateDisplayText, refreshOptions, removeSelectedValue

        	-- Update display text and chips
        	function updateDisplayText()
        		-- Clear existing chips
        		for _, child in pairs(chipsContainer:GetChildren()) do
        			if child:IsA("Frame") then
        				child:Destroy()
        			end
        		end

        		if #selectedValues == 0 then
        			-- Show placeholder text
        			selectButton.Text = "  " .. placeholder
        			selectButton.TextColor3 = Colors.Text.Secondary
        			chipsContainer.Visible = false
        		elseif multiSelect and #selectedValues > 0 then
        			-- Hide button text and show chips
        			selectButton.Text = ""
        			chipsContainer.Visible = true

        			local totalWidth = 0

        			-- Create chips for all selected items
        			for i, value in ipairs(selectedValues) do
        				local displayText = value
        				for _, option in ipairs(options) do
        					if option.value == value then
        						displayText = option.text
        						break
        					end
        				end

        				-- Create chip container
        				local chip = Instance.new("Frame")
        				chip.Size = UDim2.new(0, 0, 0, selectHeight - 8) -- Auto-width, fit height
        				chip.BackgroundColor3 = Colors.Accent.Primary
        				chip.BorderSizePixel = 0
        				chip.ZIndex = chipsContainer.ZIndex + 1
        				chip.LayoutOrder = i
        				chip.Parent = chipsContainer

        				-- Chip corner radius
        				local chipCorner = Instance.new("UICorner")
        				chipCorner.CornerRadius = UDim.new(0, (selectHeight - 8) / 2) -- Pill shape
        				chipCorner.Parent = chip

        				-- Chip text
        				local chipText = Instance.new("TextLabel")
        				chipText.Size = UDim2.new(1, -20, 1, 0) -- Leave space for X button
        				chipText.Position = UDim2.new(0, 8, 0, 0)
        				chipText.BackgroundTransparency = 1
        				chipText.Text = displayText
        				chipText.TextColor3 = Color3.fromRGB(255, 255, 255)
        				chipText.TextXAlignment = Enum.TextXAlignment.Left
        				chipText.TextYAlignment = Enum.TextYAlignment.Center
        				chipText.Font = Enum.Font.Gotham
        				chipText.TextSize = isForAccordion and 10 or 12
        				chipText.TextScaled = false
        				chipText.ZIndex = chip.ZIndex + 1
        				chipText.Parent = chip

        				-- X button for removing chip
        				local removeButton = Instance.new("TextButton")
        				removeButton.Size = UDim2.new(0, 16, 0, 16)
        				removeButton.Position = UDim2.new(1, -18, 0.5, -8)
        				removeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        				removeButton.BackgroundTransparency = 0.2
        				removeButton.BorderSizePixel = 0
        				removeButton.Text = "×"
        				removeButton.TextColor3 = Colors.Accent.Primary
        				removeButton.TextSize = 12
        				removeButton.Font = Enum.Font.GothamBold
        				removeButton.ZIndex = chip.ZIndex + 2
        				removeButton.Parent = chip

        				-- X button corner radius
        				local removeCorner = Instance.new("UICorner")
        				removeCorner.CornerRadius = UDim.new(0, 8)
        				removeCorner.Parent = removeButton

        				-- X button hover effect
        				removeButton.MouseEnter:Connect(function()
        					removeButton.BackgroundTransparency = 0
        				end)

        				removeButton.MouseLeave:Connect(function()
        					removeButton.BackgroundTransparency = 0.2
        				end)

        				-- Remove chip on click
        				removeButton.MouseButton1Click:Connect(function()
        					removeSelectedValue(value)
        				end)

        				-- Auto-size chip based on text
        				local textBounds = game:GetService("TextService"):GetTextSize(
        					displayText,
        					chipText.TextSize,
        					chipText.Font,
        					Vector2.new(200, chipText.AbsoluteSize.Y)
        				)
        				local chipWidth = textBounds.X + 32 -- Text width + padding + X button
        				chip.Size = UDim2.new(0, chipWidth, 0, selectHeight - 8)

        				-- Add to total width for canvas sizing
        				totalWidth = totalWidth + chipWidth + 4 -- Include padding
        			end

        			-- Update canvas size for horizontal scrolling
        			chipsContainer.CanvasSize = UDim2.new(0, math.max(totalWidth, chipsContainer.AbsoluteSize.X), 0, 0)
        		else
        			-- Single select mode
        			local displayText = selectedValues[1]
        			for _, option in ipairs(options) do
        				if option.value == selectedValues[1] then
        					displayText = option.text
        					break
        				end
        			end
        			selectButton.Text = "  " .. (displayText or "Unknown")
        			selectButton.TextColor3 = Colors.Text.Primary
        			chipsContainer.Visible = false
        		end
        	end

        	-- Remove a selected value (for chip removal)
        	function removeSelectedValue(value)
        		for i, val in ipairs(selectedValues) do
        			if val == value then
        				table.remove(selectedValues, i)
        				break
        			end
        		end
        		updateDisplayText()
        		refreshOptions()

        		-- Save to configuration
        		if flag then
        			local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
        			settings:SetValue(flag, valueToSave)
        		end

        		callback(selectedValues, value)
        	end

        	-- Show/hide bottom sheet with animation
        	local TweenService = game:GetService("TweenService")

        	local function showBottomSheet()
        		bottomSheetOverlay.Visible = true

        		-- Call OnDropdownOpen callback when dropdown is opened
        		if onDropdownOpen then
        			onDropdownOpen(options, function(newOptions)
        				-- Callback function to update options
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Refresh the options display
        					refreshOptions()
        				end
        			end)
        		end

        		-- Animate overlay fade in
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 0.3}
        		)
        		overlayTween:Play()

        		-- Animate bottom sheet slide up from bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, -bottomSheetHeight - 20)}
        		)
        		sheetTween:Play()

        		-- Animate arrow rotation
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 180}
        		)
        		arrowTween:Play()
        	end

        	local function hideBottomSheet()
        		-- Animate overlay fade out
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 1}
        		)

        		-- Animate bottom sheet slide down to bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, 20)}
        		)

        		-- Animate arrow rotation back
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 0}
        		)
        		arrowTween:Play()

        		sheetTween:Play()
        		overlayTween:Play()

        		overlayTween.Completed:Connect(function()
        			bottomSheetOverlay.Visible = false
        		end)
        	end

        	local function searchOptions(query)
        		local searchText = query:lower()
        		local visibleCount = 0
        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") then
        				local optionTextLabel = child:FindFirstChild("TextLabel")
        				if optionTextLabel then
        					local optionText = string.lower(optionTextLabel.Text)
        					local isVisible = searchText == "" or string.find(optionText, searchText, 1, true) ~= nil
        					child.Visible = isVisible
        					if isVisible then
        						visibleCount = visibleCount + 1
        					end
        				end
        			end
        		end
        		-- Update scroll canvas size based on visible items
        		local visibleHeight = visibleCount * 50
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, visibleHeight)
        	end

        	-- Create options
        	function refreshOptions()
        		-- Save current search text
        		local searchTextBefore = searchBox and searchBox.Text or ""

        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") or child:IsA("UIListLayout") then
        				if child:IsA("TextButton") then
        					child:Destroy()
        				end
        			end
        		end

        		-- Update canvas size for scrolling (smaller option height)
        		local totalHeight = #options * 35
        		optionsContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)

        		-- Update bottom sheet height based on current options count
        		local newBottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        		if newBottomSheetHeight ~= bottomSheetHeight then
        			bottomSheetHeight = newBottomSheetHeight
        			bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        		end

        		for i, option in ipairs(options) do
        			-- Modern option button (smaller)
        			local optionButton = Instance.new("TextButton")
        			optionButton.Size = UDim2.new(1, 0, 0, 35)
        			optionButton.Position = UDim2.new(0, 0, 0, (i-1) * 35)
        			optionButton.BackgroundColor3 = Colors.Surface.Default
        			optionButton.BackgroundTransparency = 0
        			optionButton.BorderSizePixel = 0
        			optionButton.Text = ""
        			optionButton.ZIndex = 103
        			optionButton.Parent = optionsContainer

        			-- Option text (smaller)
        			local optionText = Instance.new("TextLabel")
        			optionText.Size = UDim2.new(1, -48, 1, 0)
        			optionText.Position = UDim2.new(0, 16, 0, 0)
        			optionText.BackgroundTransparency = 1
        			optionText.Text = option.text
        			optionText.TextColor3 = Colors.Text.Primary
        			optionText.TextXAlignment = Enum.TextXAlignment.Left
        			optionText.TextYAlignment = Enum.TextYAlignment.Center
        			optionText.Font = Enum.Font.Gotham
        			optionText.TextSize = 13
        			optionText.ZIndex = 104
        			optionText.Parent = optionButton

        			-- Modern checkmark/selection indicator (smaller)
        			local checkmark = Instance.new("Frame")
        			checkmark.Size = UDim2.new(0, 16, 0, 16)
        			checkmark.Position = UDim2.new(1, -28, 0.5, -8)
        			checkmark.BackgroundColor3 = Colors.Status.Success
        			checkmark.BorderSizePixel = 0
        			checkmark.Visible = false
        			checkmark.ZIndex = 104
        			checkmark.Parent = optionButton

        			local checkCorner = Instance.new("UICorner")
        			checkCorner.CornerRadius = UDim.new(0, 8)
        			checkCorner.Parent = checkmark

        			local checkIcon = Instance.new("TextLabel")
        			checkIcon.Size = UDim2.new(1, 0, 1, 0)
        			checkIcon.BackgroundTransparency = 1
        			checkIcon.Text = "✓"
        			checkIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
        			checkIcon.TextXAlignment = Enum.TextXAlignment.Center
        			checkIcon.TextYAlignment = Enum.TextYAlignment.Center
        			checkIcon.Font = Enum.Font.GothamBold
        			checkIcon.TextSize = 10
        			checkIcon.ZIndex = 105
        			checkIcon.Parent = checkmark

        			-- Check if selected
        			local isSelected = false
        			for _, val in ipairs(selectedValues) do
        				if val == option.value then
        					isSelected = true
        					break
        				end
        			end

        			if isSelected then
        				checkmark.Visible = true
        				optionButton.BackgroundColor3 = Colors.Input.Background
        				optionText.TextColor3 = Colors.Status.Success
        			end

        			-- Hover effect
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Input.Background
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Click handler
        			optionButton.MouseButton1Click:Connect(function()
        				if multiSelect then
        					local found = false
        					for j, val in ipairs(selectedValues) do
        						if val == option.value then
        							table.remove(selectedValues, j)
        							found = true
        							break
        						end
        					end

        					if not found then
        						table.insert(selectedValues, option.value)
        					end

        					refreshOptions()
        				else
        					selectedValues = {option.value}
        					isOpen = false
        					hideBottomSheet()
        				end

        				updateDisplayText()

        				-- Save to configuration
        				if flag then
        					local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
        					settings:SetValue(flag, valueToSave)
        				end

        				callback(selectedValues, option.value)
        			end)

        			-- Hover effects
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.OptionHover
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.Option
        				end
        			end)
        		end

        		-- Restore value search after refresh
        		if searchBox then
        			searchOptions(searchTextBefore)
        		end
        	end

        	-- Toggle bottom sheet
        	local function toggleBottomSheet()
        		isOpen = not isOpen
        		if isOpen then
        			showBottomSheet()
        		else
        			hideBottomSheet()
        		end
        	end

        	-- Button handlers
        	selectButton.MouseButton1Click:Connect(toggleBottomSheet)

        	-- Overlay click to close
        	bottomSheetOverlay.MouseButton1Click:Connect(function()
        		if isOpen then
        			isOpen = false
        			hideBottomSheet()
        		end
        	end)

        	-- Search filter
        	searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        		searchOptions(searchBox.Text)
        	end)

        	-- Initial setup
        	refreshOptions()
        	updateDisplayText()

        	-- SelectBox API
        	local selectBoxAPI = {
        		SelectBox = selectContainer
        	}

        	function selectBoxAPI:GetSelected()
        		return selectedValues
        	end

        	function selectBoxAPI:SetSelected(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Clear()
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Refresh(newOptions)
        		rawOptions = newOptions
        		options = {}
        		for i, option in ipairs(rawOptions) do
        			if type(option) == "string" then
        				table.insert(options, {text = option, value = option})
        			elseif type(option) == "table" and option.text and option.value then
        				table.insert(options, option)
        			end
        		end
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Set(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		updateDisplayText()
        	end

        	function selectBoxAPI:Cleanup()
        		if bottomSheetOverlay then
        			bottomSheetOverlay:Destroy()
        		end
        		if selectContainer then
        			selectContainer:Destroy()
        		end
        	end

        	-- Register component
        	if registerComponent then
        		registerComponent(flag, selectBoxAPI)
        	end

        	-- Execute OnInit callback after component is fully created
        	if onInit and type(onInit) == "function" then
        		-- Preserve selected values before calling onInit
        		local preservedSelectedValues = selectedValues

        		-- Call OnInit with selectBoxAPI and options update function
        		onInit(selectBoxAPI, {
        			currentOptions = options,
        			updateOptions = function(newOptions)
        				-- Callback function to update options on initialization
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Restore selected values after options update
        					selectedValues = preservedSelectedValues

        					-- Refresh the options display
        					refreshOptions()
        					-- Update display text after refreshing options
        					updateDisplayText()
        				end
        			end
        		})
        	end

        	return selectBoxAPI
        end

        return SelectBox

    end

    -- Module: components/separator
    EmbeddedModules["components/separator"] = function()
        --[[
        	Separator Component
        	EzUI Library - Modular Component

        	Creates a horizontal line separator
        ]]
        local Separator = {}

        local Colors

        function Separator:Init(_colors)
        	Colors = _colors
        end

        function Separator:Create(config)
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	local separator = Instance.new("Frame")
        	if isForAccordion then
        		separator.Size = UDim2.new(1, 0, 0, 1)
        		-- Don't set Position for accordion separators - let UIListLayout handle it
        		separator.ZIndex = 5
        	else
        		separator.Size = UDim2.new(1, -20, 0, 1)
        		separator.Position = UDim2.new(0, 10, 0, currentY + 5)
        		separator.ZIndex = 3
        		separator:SetAttribute("ComponentStartY", currentY)
        	end
        	separator.BackgroundColor3 = Colors.Special.Divider
        	separator.BorderSizePixel = 0
        	separator.Parent = parentContainer

        	-- Create Separator API
        	local separatorAPI = {
        		Separator = separator
        	}

        	function separatorAPI:SetColor(color)
        		separator.BackgroundColor3 = color
        	end

        	return separatorAPI
        end

        return Separator

    end

    -- Module: components/textbox
    EmbeddedModules["components/textbox"] = function()
        --[[
        	TextBox Component
        	EzUI Library - Modular Component

        	Creates a text input field with character counter
        ]]
        local TextBox = {}

        local Colors

        function TextBox:Init(_colors)
        	Colors = _colors
        end

        function TextBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local placeholder = config.Placeholder or "Enter text..."
        	local defaultText = config.Default or ""
        	local callback = config.Callback or function() end
        	local maxLength = config.MaxLength or 100
        	local multiline = config.Multiline or false
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Button configuration
        	local buttons = config.Buttons or {} -- Array of button configs: {Text="Submit", Callback=function() end}
        	local hasButtons = #buttons > 0

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- TextBox state
        	local currentText = defaultText

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		else
        		end

        		if flagValue ~= nil then
        			currentText = flagValue
        			defaultText = currentText
        		end
        	end

        		-- Calculate heights based on whether we have a title label
        	local hasTitle = name and name ~= ""
        	local labelHeight = hasTitle and 18 or 0
        	local inputHeight = multiline and (isForAccordion and 60 or 80) or (isForAccordion and 25 or 30)
        	local totalHeight = labelHeight + inputHeight + (hasTitle and 2 or 0) -- 2px spacing between label and input

        	-- Main textbox container
        	local textBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		textBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
        		textBoxContainer.ZIndex = 6
        	else
        		textBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		textBoxContainer.ZIndex = 3
        		textBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	textBoxContainer.BackgroundTransparency = 1
        	textBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	textBoxContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = textBoxContainer
        	end

        	-- Calculate button width (each button is 80px wide + 5px spacing)
        	local buttonWidth = hasButtons and (#buttons * 85) or 0 -- 80px + 5px spacing per button

        	-- TextBox input
        	local textBox = Instance.new("TextBox")
        	if hasTitle then
        		textBox.Size = UDim2.new(1, -buttonWidth, 0, inputHeight)
        		textBox.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		if hasButtons then
        			textBox.Size = UDim2.new(1, -buttonWidth, 1, 0)
        		else
        			textBox.Size = UDim2.new(1, 0, 1, 0)
        		end
        		textBox.Position = UDim2.new(0, 0, 0, 0)
        	end
        	textBox.BackgroundColor3 = Colors.Input.Background
        	textBox.BorderColor3 = Colors.Input.Border
        	textBox.BorderSizePixel = 1
        	textBox.Text = defaultText
        	textBox.PlaceholderText = placeholder
        	textBox.TextColor3 = Colors.Input.Text
        	textBox.PlaceholderColor3 = Colors.Text.Tertiary
        	textBox.Font = Enum.Font.SourceSans
        	textBox.TextSize = isForAccordion and 12 or 14
        	textBox.TextXAlignment = Enum.TextXAlignment.Left
        	textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        	textBox.MultiLine = multiline
        	textBox.TextWrapped = multiline
        	textBox.TextScaled = false -- Prevent text from scaling down automatically
        	textBox.ClearTextOnFocus = false
        	textBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	textBox.ZIndex = isForAccordion and 7 or 4
        	textBox.Parent = textBoxContainer

        	-- Add padding to TextBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.PaddingTop = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.PaddingBottom = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.Parent = textBox

        	-- Round corners
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 4)
        	corner.Parent = textBox

        	-- Character counter (if maxLength is set)
        	local charCounter = nil
        	if maxLength and maxLength > 0 then
        		charCounter = Instance.new("TextLabel")
        		charCounter.Size = UDim2.new(0, 50, 0, 15)
        		charCounter.Position = UDim2.new(1, -55, 1, -18)
        		charCounter.BackgroundTransparency = 1
        		charCounter.Text = string.len(currentText) .. "/" .. maxLength
        		charCounter.TextColor3 = Colors.Text.Tertiary
        		charCounter.Font = Enum.Font.SourceSans
        		charCounter.TextSize = isForAccordion and 10 or 12
        		charCounter.TextXAlignment = Enum.TextXAlignment.Right
        		charCounter.ZIndex = isForAccordion and 8 or 5
        		charCounter.Parent = textBoxContainer
        	end

        	-- Create buttons (if configured)
        	local buttonObjects = {}
        	if hasButtons then
        		local buttonY = hasTitle and (labelHeight + 2) or 0
        		local buttonHeight = inputHeight

        		for i, buttonConfig in ipairs(buttons) do
        			local buttonText = buttonConfig.Text or "Button"
        			local buttonCallback = buttonConfig.Callback or function() end
        			local buttonVariant = buttonConfig.Variant or "primary"

        			-- Calculate button position (buttons are positioned from right to left)
        			local buttonX = (1 - (i * 85 / textBoxContainer.AbsoluteSize.X)) -- 85px per button from right

        			local button = Instance.new("TextButton")
        			button.Size = UDim2.new(0, 80, 0, buttonHeight)
        			button.Position = UDim2.new(1, -i * 85 + 5, 0, buttonY) -- 5px spacing from edge
        			button.BackgroundColor3 = buttonVariant == "primary" and Colors.Accent.Primary or Colors.Surface.Default
        			button.BorderSizePixel = 0
        			button.Text = buttonText
        			button.TextColor3 = buttonVariant == "primary" and Color3.fromRGB(255, 255, 255) or Colors.Text.Primary
        			button.Font = Enum.Font.SourceSans
        			button.TextSize = isForAccordion and 11 or 13
        			button.ZIndex = isForAccordion and 7 or 4
        			button.Parent = textBoxContainer

        			-- Button corner radius
        			local buttonCorner = Instance.new("UICorner")
        			buttonCorner.CornerRadius = UDim.new(0, 4)
        			buttonCorner.Parent = button

        			-- Button hover effects
        			button.MouseEnter:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Hover
        				else
        					button.BackgroundColor3 = Colors.Surface.Hover
        				end
        			end)

        			button.MouseLeave:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Primary
        				else
        					button.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Button click handler
        			button.MouseButton1Click:Connect(function()
        				if buttonCallback then
        					buttonCallback(textBox.Text, textBox) -- Pass current text and textBox reference
        				end
        			end)

        			table.insert(buttonObjects, {
        				Button = button,
        				Text = buttonText,
        				Callback = buttonCallback
        			})
        		end
        	end

        	-- Function to update character counter
        	local function updateCharCounter()
        		if charCounter then
        			local textLength = string.len(textBox.Text)
        			charCounter.Text = textLength .. "/" .. maxLength

        			-- Change color based on limit
        			if textLength >= maxLength then
        				charCounter.TextColor3 = Colors.Status.Error
        			elseif textLength >= maxLength * 0.8 then
        				charCounter.TextColor3 = Colors.Status.Warning
        			else
        				charCounter.TextColor3 = Colors.Text.Tertiary
        			end
        		end
        	end

        	-- Text change handler
        	textBox.Changed:Connect(function(property)
        		if property == "Text" then
        			-- Enforce max length
        			if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
        				textBox.Text = string.sub(textBox.Text, 1, maxLength)
        			end

        			currentText = textBox.Text
        			updateCharCounter()

        			-- Save to configuration
        			if flag then
        				settings:SetValue(flag, currentText)
        			end

        			-- Call user callback
        			local success, errorMsg = pcall(function()
        				callback(currentText)
        			end)

        			if not success then
        			end
        		end
        	end)

        	-- Focus effects
        	textBox.Focused:Connect(function()
        		textBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	textBox.FocusLost:Connect(function()
        		textBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return TextBox API
        	local textBoxAPI = {
        		TextBox = textBoxContainer,
        		Buttons = buttonObjects
        	}

        	function textBoxAPI:GetText()
        		return currentText
        	end

        	function textBoxAPI:SetText(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentText)
        		end
        	end

        	function textBoxAPI:Clear()
        		textBox.Text = ""
        		currentText = ""
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			-- Check if using custom config object
        			if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        				EzUIConfig.SetValue(flag, currentText)
        			-- Fallback to EzUI.Flags
        			elseif EzUI and EzUI.Flags then
        				EzUI.Flags[flag] = currentText
        				-- Auto-save if enabled
        				if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        					saveConfiguration(EzUI.Configuration.FileName)
        				end
        			end
        		end
        	end

        	function textBoxAPI:SetPlaceholder(newPlaceholder)
        		textBox.PlaceholderText = tostring(newPlaceholder or "")
        	end

        	function textBoxAPI:Focus()
        		textBox:CaptureFocus()
        	end

        	function textBoxAPI:Blur()
        		textBox:ReleaseFocus()
        	end

        	function textBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function textBoxAPI:Set(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        	end

        	-- Button-related methods
        	function textBoxAPI:GetButton(index)
        		return buttonObjects[index]
        	end

        	function textBoxAPI:SetButtonText(index, newText)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.Text = newText
        			buttonObjects[index].Text = newText
        		end
        	end

        	function textBoxAPI:SetButtonCallback(index, newCallback)
        		if buttonObjects[index] then
        			buttonObjects[index].Callback = newCallback or function() end
        			-- Note: We can't change the connected event, but we update the stored callback
        		end
        	end

        	function textBoxAPI:EnableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0
        			buttonObjects[index].Button.TextTransparency = 0
        		end
        	end

        	function textBoxAPI:DisableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0.5
        			buttonObjects[index].Button.TextTransparency = 0.5
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, textBoxAPI)
        	end

        	return textBoxAPI
        end

        return TextBox

    end

    -- Module: components/toggle
    EmbeddedModules["components/toggle"] = function()
        --[[
        	Toggle Component
        	EzUI Library - Modular Component

        	Creates a toggle/switch with on/off states
        ]]
        local Toggle = {}

        local Colors

        function Toggle:Init(_colors)
        	Colors = _colors
        end

        function Toggle:Create(config)
        	local text = config.Name or config.Text or "Toggle"
        	local defaultValue = config.Default or false
        	local callback = config.Callback or function() end
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Toggle state
        	local isToggled = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			isToggled = flagValue
        		end
        	end

        	-- Main toggle container
        	local toggleContainer = Instance.new("Frame")
        	if isForAccordion then
        		toggleContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion toggles - let UIListLayout handle it
        		toggleContainer.ZIndex = 6
        	else
        		toggleContainer.Size = UDim2.new(1, -20, 0, 30)
        		toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
        		toggleContainer.ZIndex = 3
        		toggleContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	toggleContainer.BackgroundTransparency = 1
        	toggleContainer.Parent = parentContainer

        	-- Toggle label
        	local toggleLabel = Instance.new("TextLabel")
        	if isForAccordion then
        		toggleLabel.Size = UDim2.new(1, -45, 1, 0)
        		toggleLabel.TextSize = 12
        		toggleLabel.ZIndex = 7
        	else
        		toggleLabel.Size = UDim2.new(1, -60, 1, 0)
        		toggleLabel.TextSize = 16
        		toggleLabel.ZIndex = 4
        	end
        	toggleLabel.Position = UDim2.new(0, 0, 0, 0)
        	toggleLabel.BackgroundTransparency = 1
        	toggleLabel.Text = text
        	toggleLabel.TextColor3 = Colors.Text.Primary
        	toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	toggleLabel.Font = Enum.Font.SourceSans
        	toggleLabel.Parent = toggleContainer

        	-- Toggle switch background
        	local toggleBg = Instance.new("Frame")
        	if isForAccordion then
        		toggleBg.Size = UDim2.new(0, 40, 0, 20)
        		toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
        		toggleBg.ZIndex = 7
        	else
        		toggleBg.Size = UDim2.new(0, 50, 0, 24)
        		toggleBg.Position = UDim2.new(1, -50, 0.5, -12)
        		toggleBg.ZIndex = 4
        	end
        	toggleBg.BackgroundColor3 = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        	toggleBg.BorderSizePixel = 0
        	toggleBg.Parent = toggleContainer

        	-- Round corners for toggle background
        	local toggleBgCorner = Instance.new("UICorner")
        	toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 12)
        	toggleBgCorner.Parent = toggleBg

        	-- Toggle switch button (circle)
        	local toggleButton = Instance.new("TextButton")
        	if isForAccordion then
        		toggleButton.Size = UDim2.new(0, 16, 0, 16)
        		toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		toggleButton.ZIndex = 8
        	else
        		toggleButton.Size = UDim2.new(0, 20, 0, 20)
        		toggleButton.Position = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		toggleButton.ZIndex = 5
        	end
        	toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	toggleButton.BorderSizePixel = 0
        	toggleButton.Text = ""
        	toggleButton.Parent = toggleBg

        	-- Round corners for toggle button
        	local toggleButtonCorner = Instance.new("UICorner")
        	toggleButtonCorner.CornerRadius = UDim.new(0, isForAccordion and 8 or 10)
        	toggleButtonCorner.Parent = toggleButton

        	-- Function to update toggle appearance
        	local function updateToggleAppearance()
        		local targetBgColor = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        		local targetPosition

        		if isForAccordion then
        			targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		else
        			targetPosition = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		end

        		-- Animate background color
        		local bgTween = game:GetService("TweenService"):Create(
        			toggleBg,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{BackgroundColor3 = targetBgColor}
        		)
        		bgTween:Play()

        		-- Animate button position
        		local buttonTween = game:GetService("TweenService"):Create(
        			toggleButton,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = targetPosition}
        		)
        		buttonTween:Play()
        	end

        	-- Toggle click handler
        	local function handleToggle()
        		isToggled = not isToggled
        		updateToggleAppearance()

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, isToggled)
        		end

        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(isToggled)
        		end)

        		if not success then
        		end
        	end

        	toggleButton.MouseButton1Click:Connect(handleToggle)

        	-- Also allow clicking the background to toggle
        	toggleBg.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 then
        			handleToggle()
        		end
        	end)

        	-- Hover effects
        	toggleButton.MouseEnter:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	toggleButton.MouseLeave:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	-- Return Toggle API
        	local toggleAPI = {
        		Toggle = toggleContainer
        	}

        	function toggleAPI:SetValue(newValue)
        		if type(newValue) ~= "boolean" and newValue == isToggled then
        			return
        		end

        		isToggled = newValue
        		updateToggleAppearance()

        		-- Save to configuration
        		if not flag then
        			return
        		end

        		settings:SetValue(flag, isToggled)
        	end

        	function toggleAPI:GetValue()
        		return isToggled
        	end

        	function toggleAPI:SetText(newText)
        		text = newText
        		toggleLabel.Text = newText
        	end

        	function toggleAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	toggleAPI.Set = toggleAPI.SetValue

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, toggleAPI)
        	end

        	return toggleAPI
        end

        return Toggle

    end

    -- Module: components/window
    EmbeddedModules["components/window"] = function()
        --[[
        	Window Component
        	EzUI Library - Modular Component

        	Creates main window with responsive sizing and dragging
        ]]

        local Window = {}
        local Colors
        local Accordion
        local Button
        local Label
        local NumberBox
        local Notification
        local SelectBox
        local Separator
        local Tab
        local TextBox
        local Toggle

        function Window:Init(_colors, _accordion, _button, _label, _numberbox, _notification, _selectbox, _separator, _tab, _textbox, _toggle)
            Colors = _colors
            Accordion = _accordion
            Button = _button
            Label = _label
            NumberBox = _numberbox
            Notification = _notification
            SelectBox = _selectbox
            Separator = _separator
            Tab = _tab
            TextBox = _textbox
            Toggle = _toggle

            -- Debug: Verify Colors module is loaded
            if not Colors then
            elseif not Colors.Background then
            end
        end

        function Window:GetViewportSize()
        	local camera = workspace.CurrentCamera
        	if not camera then
        		camera = workspace:WaitForChild("CurrentCamera", 5)
        	end

        	local viewportSize = camera.ViewportSize

        	if viewportSize.X <= 1 or viewportSize.Y <= 1 then
        		viewportSize = Vector2.new(1366, 768)
        	end

        	return viewportSize
        end

        function Window:CalculateDynamicSize(width, height)
        	local viewportSize = self:GetViewportSize()

        	local baseWidth = width or (viewportSize.X * 0.7)
        	local baseHeight = height or (viewportSize.Y * 0.4)

        	local scaleMultiplier = 1
        	if viewportSize.X >= 1920 then
        		scaleMultiplier = 1.2
        	elseif viewportSize.X >= 1366 then
        		scaleMultiplier = 1.0
        	elseif viewportSize.X >= 1024 then
        		scaleMultiplier = 0.9
        	else
        		scaleMultiplier = 0.8
        	end

        	local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
        	local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))

        	return finalWidth, finalHeight
        end

        function Window:CreateFloatingButton(screenGui, frame, toggleMinimizeCallback, autoShow)
        	-- Create floating button (visibility based on AutoShow parameter)
        	local floatingButton = Instance.new("Frame")
        	floatingButton.Size = UDim2.new(0, 50, 0, 50)
        	floatingButton.Position = UDim2.new(0, 0, 0.5, -25) -- Middle left by default
        	floatingButton.BackgroundColor3 = Colors.Background.Primary
        	floatingButton.BorderSizePixel = 0
        	floatingButton.ZIndex = 100
        	floatingButton.Visible = not autoShow -- Show floating button if window starts hidden
        	floatingButton.Active = true
        	floatingButton.Parent = screenGui

        	-- Rounded corners for floating button
        	local floatingCorner = Instance.new("UICorner")
        	floatingCorner.CornerRadius = UDim.new(0, 12)
        	floatingCorner.Parent = floatingButton

        	-- Arrow icon
        	local arrowIcon = Instance.new("TextLabel")
        	arrowIcon.Size = UDim2.new(1, 0, 1, 0)
        	arrowIcon.Position = UDim2.new(0, 0, 0, 0)
        	arrowIcon.BackgroundTransparency = 1
        	arrowIcon.Text = ">"
        	arrowIcon.TextColor3 = Colors.Text.Primary
        	arrowIcon.TextSize = 24
        	arrowIcon.Font = Enum.Font.SourceSansBold
        	arrowIcon.TextXAlignment = Enum.TextXAlignment.Center
        	arrowIcon.TextYAlignment = Enum.TextYAlignment.Center
        	arrowIcon.ZIndex = 101
        	arrowIcon.Parent = floatingButton

        	-- Click detector for floating button
        	local floatingClickButton = Instance.new("TextButton")
        	floatingClickButton.Size = UDim2.new(1, 0, 1, 0)
        	floatingClickButton.BackgroundTransparency = 1
        	floatingClickButton.Text = ""
        	floatingClickButton.ZIndex = 102
        	floatingClickButton.Parent = floatingButton

        	-- Shadow effect for floating button
        	local floatingShadow = Instance.new("Frame")
        	floatingShadow.Size = UDim2.new(1, 4, 1, 4)
        	floatingShadow.Position = UDim2.new(0, -2, 0, -2)
        	floatingShadow.BackgroundColor3 = Colors.Background.Overlay
        	floatingShadow.BackgroundTransparency = 0.8
        	floatingShadow.BorderSizePixel = 0
        	floatingShadow.ZIndex = 99
        	floatingShadow.Parent = floatingButton

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 12)
        	shadowCorner.Parent = floatingShadow

        	-- Hover effects for floating button
        	local originalColor = Colors.Background.Primary
        	floatingClickButton.MouseEnter:Connect(function()
        		floatingButton.BackgroundColor3 = Colors.Background.Secondary
        	end)

        	floatingClickButton.MouseLeave:Connect(function()
        		floatingButton.BackgroundColor3 = originalColor
        	end)

        	-- Dragging functionality for floating button
        	local floatingDragging = false
        	local floatingDragInput, floatingDragStart, floatingStartPos
        	local isOnLeftSide = true -- Track which side the button is on

        	local function snapFloatingButton()
        		-- Get viewport size
        		local viewportSize = Window:GetViewportSize()
        		local currentPos = floatingButton.AbsolutePosition
        		local buttonWidth = floatingButton.AbsoluteSize.X
        		local buttonHeight = floatingButton.AbsoluteSize.Y

        		-- Determine which side is closer (left or right)
        		local distanceToLeft = currentPos.X
        		local distanceToRight = viewportSize.X - (currentPos.X + buttonWidth)

        		local targetX, targetY
        		local offsetAmount = 15 -- How much to offset off-screen

        		if distanceToLeft < distanceToRight then
        			-- Snap to left side - slightly off-screen
        			targetX = -offsetAmount
        			isOnLeftSide = true
        			arrowIcon.Text = ">"
        		else
        			-- Snap to right side - slightly off-screen
        			targetX = viewportSize.X - buttonWidth + offsetAmount
        			isOnLeftSide = false
        			arrowIcon.Text = "<"
        		end

        		-- Keep Y position but clamp to viewport bounds
        		targetY = math.max(10, math.min(viewportSize.Y - buttonHeight - 10, currentPos.Y))

        		-- Animate to snapped position
        		floatingButton:TweenPosition(
        			UDim2.new(0, targetX, 0, targetY),
        			Enum.EasingDirection.Out,
        			Enum.EasingStyle.Quad,
        			0.3,
        			true
        		)
        	end

        	local function updateFloatingDrag(input)
        		local delta = input.Position - floatingDragStart
        		local newPos = UDim2.new(
        			floatingStartPos.X.Scale,
        			floatingStartPos.X.Offset + delta.X,
        			floatingStartPos.Y.Scale,
        			floatingStartPos.Y.Offset + delta.Y
        		)
        		floatingButton.Position = newPos
        	end

        	floatingClickButton.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragging = true
        			floatingDragStart = input.Position
        			floatingStartPos = floatingButton.Position

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					floatingDragging = false
        					-- Snap to nearest side when drag ends
        					pcall(snapFloatingButton)
        				end
        			end)
        		end
        	end)

        	floatingClickButton.InputChanged:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseMovement or
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragInput = input
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if floatingDragging and input == floatingDragInput then
        			updateFloatingDrag(input)
        		end
        	end)

        	-- Click detection for restore window
        	local clickStartTime = 0
        	local clickStartPos = Vector2.new(0, 0)

        	floatingClickButton.MouseButton1Down:Connect(function()
        		clickStartTime = tick()
        		clickStartPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        	end)

        	floatingClickButton.MouseButton1Up:Connect(function()
        		local clickDuration = tick() - clickStartTime
        		local currentPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        		local dragDistance = (currentPos - clickStartPos).Magnitude

        		-- Only toggle if it was a quick click (< 0.2s) and minimal drag (< 5 pixels)
        		if clickDuration < 0.2 and dragDistance < 5 then
        			toggleMinimizeCallback()
        		end
        	end)

        	return {
        		Frame = floatingButton,
        		SnapToEdge = snapFloatingButton
        	}
        end

        function Window:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	local isMinimized = false

        	local function toggleMinimize()
        		isMinimized = not isMinimized

        		if isMinimized then
        			-- Minimize: hide window and show floating button
        			originalPosition = frame.Position
        			frame.Visible = false

        			-- Show floating button with animation
        			floatingButton.Frame.Visible = true
        			floatingButton.Frame.Size = UDim2.new(0, 0, 0, 50)
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 50, 0, 50),
        				Enum.EasingDirection.Out,
        				Enum.EasingStyle.Quad,
        				0.3,
        				true,
        				function()
        					-- Snap to side after appearing
        					floatingButton.SnapToEdge()
        				end
        			)
        		else
        			-- Restore: hide floating button and show window
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 0, 0, 50),
        				Enum.EasingDirection.In,
        				Enum.EasingStyle.Quad,
        				0.2,
        				true,
        				function()
        					floatingButton.Frame.Visible = false
        					frame.Visible = true
        					frame.Position = originalPosition
        				end
        			)
        		end
        	end

        	return {
        		Toggle = toggleMinimize,
        		IsMinimized = function() return isMinimized end
        	}
        end

        function Window:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	-- Create resize handle in bottom-right corner
        	local resizeHandle = Instance.new("ImageButton")
        	resizeHandle.Size = UDim2.new(0, 20, 0, 20)
        	resizeHandle.Position = UDim2.new(1, -20, 1, -20)
        	resizeHandle.BackgroundColor3 = Colors.Accent.Primary
        	resizeHandle.BackgroundTransparency = 0.7
        	resizeHandle.BorderSizePixel = 0
            resizeHandle.Image = "rbxassetid://16898613613"
            resizeHandle.ImageRectOffset = Vector2.new(820,196)
        	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
        	resizeHandle.ZIndex = 10
        	resizeHandle.Active = true
        	resizeHandle.Parent = frame

        	-- Corner radius
        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 4)
        	handleCorner.Parent = resizeHandle

        	-- Hover effect
        	resizeHandle.MouseEnter:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.3
        	end)

        	resizeHandle.MouseLeave:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.7
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startSize

        	resizeHandle.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startSize = frame.AbsoluteSize

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new size
        			local newWidth = startSize.X + delta.X
        			local newHeight = startSize.Y + delta.Y

        			-- Apply min/max constraints
        			newWidth = math.max(minWidth or 300, newWidth)
        			newHeight = math.max(minHeight or 200, newHeight)

        			if maxWidth then
        				newWidth = math.min(maxWidth, newWidth)
        			end

        			if maxHeight then
        				newHeight = math.min(maxHeight, newHeight)
        			end

        			-- Update frame size
        			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		end
        	end)

        	return resizeHandle
        end

        function Window:CreateTabPanelResizer(tabPanel, scrollFrame, minTabWidth, maxTabWidth)
        	-- Create resize handle on right edge of tab panel
        	local resizer = Instance.new("Frame")
        	resizer.Size = UDim2.new(0, 4, 1, 0)
        	resizer.Position = UDim2.new(1, 0, 0, 0)
        	resizer.BackgroundColor3 = Colors.Accent.Primary
        	resizer.BackgroundTransparency = 0.9
        	resizer.BorderSizePixel = 0
        	resizer.ZIndex = 10
        	resizer.Active = true
        	resizer.Parent = tabPanel

        	-- Visual indicator (appears on hover)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 2, 1, 0)
        	indicator.Position = UDim2.new(0, 1, 0, 0)
        	indicator.BackgroundColor3 = Colors.Accent.Primary
        	indicator.BackgroundTransparency = 1
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = 11
        	indicator.Parent = resizer

        	-- Hover effects
        	resizer.MouseEnter:Connect(function()
        		resizer.BackgroundTransparency = 0.7
        		indicator.BackgroundTransparency = 0
        	end)

        	resizer.MouseLeave:Connect(function()
        		resizer.BackgroundTransparency = 0.9
        		indicator.BackgroundTransparency = 1
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startWidth

        	resizer.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startWidth = tabPanel.AbsoluteSize.X

        			-- Show indicator while resizing
        			indicator.BackgroundTransparency = 0

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        					indicator.BackgroundTransparency = 1
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new width
        			local newWidth = startWidth + delta.X

        			-- Apply constraints
        			newWidth = math.max(minTabWidth or 80, newWidth)
        			newWidth = math.min(maxTabWidth or 300, newWidth)

        			-- Update tab panel width
        			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)

        			-- Update scroll frame position and size
        			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        		end
        	end)

        	return resizer
        end

        function Window:Create(config)
        	-- Ensure Colors is initialized with detailed error
        	if not Colors then
        		error("Window:Create() - Colors module is nil. Window:Init() may not have been called or Colors parameter was nil.")
        	end

        	if not Colors.Background then
        		error("Window:Create() - Colors.Background is nil. The Colors module may not have loaded correctly.")
        	end

        	local title = config.Title or "EzUI Window"
        	local width = config.Width
        	local height = config.Height
        	local opacity = config.Opacity or 0.9
        	local autoShow = config.AutoShow ~= nil and config.AutoShow or true
        	local draggable = config.Draggable ~= nil and config.Draggable or true
        	local resizable = config.Resizable ~= nil and config.Resizable or true
        	local tabPanelResizable = config.TabPanelResizable ~= nil and config.TabPanelResizable or true
        	local backgroundColor = config.BackgroundColor or Colors.Background.Secondary
        	local cornerRadius = config.CornerRadius or 8
        	local minWidth = config.MinWidth or 300
        	local minHeight = config.MinHeight or 200
        	local maxWidth = config.MaxWidth
        	local maxHeight = config.MaxHeight
        	local tabPanelWidth = config.TabPanelWidth or 130
        	local minTabPanelWidth = config.MinTabPanelWidth or 80
        	local maxTabPanelWidth = config.MaxTabPanelWidth or 300
        	local settings = config.Settings or {}
        	local autoAdapt = config.AutoAdapt ~= nil and config.AutoAdapt or true

        	-- Close callback functionality
        	local onCloseCallback = config.OnClose or nil

        	opacity = math.max(0.1, math.min(1.0, opacity))

        	local screenGui = Instance.new("ScreenGui")
        	screenGui.Name = title
        	screenGui.ResetOnSpawn = false
        	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        	local windowWidth, windowHeight = self:CalculateDynamicSize(width, height)

        	-- Main window frame
        	local frame = Instance.new("Frame")
        	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
        	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
        	frame.BackgroundColor3 = backgroundColor
        	frame.BackgroundTransparency = 1 - opacity
        	frame.BorderSizePixel = 0
        	frame.Active = true
        	frame.ClipsDescendants = true
        	frame.ZIndex = 1
        	frame.Visible = autoShow
        	frame.Parent = screenGui

        	-- Rounded corners
        	local frameCorner = Instance.new("UICorner")
        	frameCorner.CornerRadius = UDim.new(0, cornerRadius)
        	frameCorner.Parent = frame

        	-- Title bar
        	local titleBar = Instance.new("Frame")
        	titleBar.Size = UDim2.new(1, 0, 0, 30)
        	titleBar.Position = UDim2.new(0, 0, 0, 0)
        	titleBar.BackgroundColor3 = Colors.Background.Primary
        	titleBar.BorderSizePixel = 0
        	titleBar.ZIndex = 2
        	titleBar.Parent = frame

        	-- Title bar rounded corners (top only)
        	local titleCorner = Instance.new("UICorner")
        	titleCorner.CornerRadius = UDim.new(0, cornerRadius)
        	titleCorner.Parent = titleBar

        	-- Title text
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.Size = UDim2.new(1, -70, 1, 0)
        	titleLabel.Position = UDim2.new(0, 10, 0, 0)
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = title
        	titleLabel.TextColor3 = Colors.Text.Primary
        	titleLabel.TextSize = 16
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	titleLabel.ZIndex = 3
        	titleLabel.Parent = titleBar

        	-- Minimize button
        	local minimizeBtn = Instance.new("TextButton")
        	minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
        	minimizeBtn.Position = UDim2.new(1, -60, 0, 0)
        	minimizeBtn.BackgroundTransparency = 1
        	minimizeBtn.Text = "−"
        	minimizeBtn.TextColor3 = Colors.Text.Primary
        	minimizeBtn.TextSize = 24
        	minimizeBtn.Font = Enum.Font.SourceSansBold
        	minimizeBtn.ZIndex = 3
        	minimizeBtn.Parent = titleBar

        	minimizeBtn.MouseEnter:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Accent.Primary
        	end)

        	minimizeBtn.MouseLeave:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Close button
        	local closeBtn = Instance.new("TextButton")
        	closeBtn.Size = UDim2.new(0, 30, 0, 30)
        	closeBtn.Position = UDim2.new(1, -30, 0, 0)
        	closeBtn.BackgroundTransparency = 1
        	closeBtn.Text = "×"
        	closeBtn.TextColor3 = Colors.Text.Primary
        	closeBtn.TextSize = 24
        	closeBtn.Font = Enum.Font.SourceSansBold
        	closeBtn.ZIndex = 3
        	closeBtn.Parent = titleBar

        	closeBtn.MouseEnter:Connect(function()
        		closeBtn.TextColor3 = Colors.Status.Error
        	end)

        	closeBtn.MouseLeave:Connect(function()
        		closeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Create confirmation dialog elements (hidden by default)
        	local confirmationOverlay = Instance.new("Frame")
        	confirmationOverlay.Size = UDim2.new(1, 0, 1, 0)
        	confirmationOverlay.Position = UDim2.new(0, 0, 0, 0)
        	confirmationOverlay.BackgroundColor3 = Colors.Special.Overlay
        	confirmationOverlay.BackgroundTransparency = 0.5
        	confirmationOverlay.BorderSizePixel = 0
        	confirmationOverlay.ZIndex = 100
        	confirmationOverlay.Visible = false
        	confirmationOverlay.Parent = frame

        	local confirmationDialog = Instance.new("Frame")
        	confirmationDialog.Size = UDim2.new(0, 300, 0, 130)
        	confirmationDialog.Position = UDim2.new(0.5, -150, 0.5, -65)
        	confirmationDialog.BackgroundColor3 = Colors.Surface.Elevated
        	confirmationDialog.BorderSizePixel = 0
        	confirmationDialog.ZIndex = 101
        	confirmationDialog.Parent = confirmationOverlay

        	local confirmDialogCorner = Instance.new("UICorner")
        	confirmDialogCorner.CornerRadius = UDim.new(0, 8)
        	confirmDialogCorner.Parent = confirmationDialog

        	-- Confirmation dialog title
        	local confirmTitle = Instance.new("TextLabel")
        	confirmTitle.Size = UDim2.new(1, -20, 0, 25)
        	confirmTitle.Position = UDim2.new(0, 10, 0, 8)
        	confirmTitle.BackgroundTransparency = 1
        	confirmTitle.Text = "⚠️ Confirm Close"
        	confirmTitle.TextColor3 = Colors.Text.Primary
        	confirmTitle.TextSize = 14
        	confirmTitle.Font = Enum.Font.GothamBold
        	confirmTitle.TextXAlignment = Enum.TextXAlignment.Left
        	confirmTitle.ZIndex = 102
        	confirmTitle.Parent = confirmationDialog

        	-- Confirmation message
        	local confirmMessage = Instance.new("TextLabel")
        	confirmMessage.Size = UDim2.new(1, -20, 0, 35)
        	confirmMessage.Position = UDim2.new(0, 10, 0, 35)
        	confirmMessage.BackgroundTransparency = 1
        	confirmMessage.Text = "Are you sure you want to close?"
        	confirmMessage.TextColor3 = Colors.Text.Secondary
        	confirmMessage.TextSize = 12
        	confirmMessage.Font = Enum.Font.Gotham
        	confirmMessage.TextWrapped = true
        	confirmMessage.TextXAlignment = Enum.TextXAlignment.Left
        	confirmMessage.TextYAlignment = Enum.TextYAlignment.Top
        	confirmMessage.ZIndex = 102
        	confirmMessage.Parent = confirmationDialog

        	-- Button container
        	local buttonContainer = Instance.new("Frame")
        	buttonContainer.Size = UDim2.new(1, -20, 0, 32)
        	buttonContainer.Position = UDim2.new(0, 10, 1, -40)
        	buttonContainer.BackgroundTransparency = 1
        	buttonContainer.ZIndex = 102
        	buttonContainer.Parent = confirmationDialog

        	-- Cancel button
        	local cancelBtn = Instance.new("TextButton")
        	cancelBtn.Size = UDim2.new(0, 130, 0, 32)
        	cancelBtn.Position = UDim2.new(0, 0, 0, 0)
        	cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	cancelBtn.BorderSizePixel = 0
        	cancelBtn.Text = "Cancel"
        	cancelBtn.TextColor3 = Colors.Text.Primary
        	cancelBtn.TextSize = 13
        	cancelBtn.Font = Enum.Font.GothamBold
        	cancelBtn.ZIndex = 103
        	cancelBtn.Parent = buttonContainer

        	local cancelCorner = Instance.new("UICorner")
        	cancelCorner.CornerRadius = UDim.new(0, 6)
        	cancelCorner.Parent = cancelBtn

        	-- Confirm button
        	local confirmBtn = Instance.new("TextButton")
        	confirmBtn.Size = UDim2.new(0, 130, 0, 32)
        	confirmBtn.Position = UDim2.new(1, -130, 0, 0)
        	confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	confirmBtn.BorderSizePixel = 0
        	confirmBtn.Text = "Close"
        	confirmBtn.TextColor3 = Colors.Text.Primary
        	confirmBtn.TextSize = 13
        	confirmBtn.Font = Enum.Font.GothamBold
        	confirmBtn.ZIndex = 103
        	confirmBtn.Parent = buttonContainer

        	local confirmCorner = Instance.new("UICorner")
        	confirmCorner.CornerRadius = UDim.new(0, 6)
        	confirmCorner.Parent = confirmBtn

        	-- Button hover effects
        	cancelBtn.MouseEnter:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.SecondaryHover
        	end)

        	cancelBtn.MouseLeave:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	end)

        	confirmBtn.MouseEnter:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.DangerHover
        	end)

        	confirmBtn.MouseLeave:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	end)

        	-- Cancel button action
        	cancelBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false
        	end)

        	-- Confirm button action
        	confirmBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false

        		-- Call user close callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        			end
        		end

        		screenGui:Destroy()
        	end)

        	-- Close button shows confirmation dialog
        	closeBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = true
        	end)

        	-- Tab panel (left side)
        	local tabPanel = Instance.new("Frame")
        	tabPanel.Size = UDim2.new(0, tabPanelWidth, 1, -30)
        	tabPanel.Position = UDim2.new(0, 0, 0, 30)
        	tabPanel.BackgroundColor3 = Colors.Background.Primary
        	tabPanel.BorderSizePixel = 0
        	tabPanel.ZIndex = 2
        	tabPanel.Parent = frame

        	-- Tab scroll frame
        	local tabScrollFrame = Instance.new("ScrollingFrame")
        	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
        	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.BackgroundTransparency = 1
        	tabScrollFrame.BorderSizePixel = 0
        	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.ScrollBarThickness = 6
        	tabScrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	tabScrollFrame.ZIndex = 3
        	tabScrollFrame.Parent = tabPanel

        	-- List layout for tabs
        	local tabListLayout = Instance.new("UIListLayout")
        	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	tabListLayout.Padding = UDim.new(0, 3)
        	tabListLayout.Parent = tabScrollFrame

        	-- Content scroll frame
        	local scrollFrame = Instance.new("ScrollingFrame")
        	scrollFrame.Size = UDim2.new(1, -tabPanelWidth, 1, -30)
        	scrollFrame.Position = UDim2.new(0, tabPanelWidth, 0, 30)
        	scrollFrame.BackgroundTransparency = 1
        	scrollFrame.BorderSizePixel = 0
        	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	scrollFrame.ScrollBarThickness = 8
        	scrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	scrollFrame.ClipsDescendants = true
        	scrollFrame.ZIndex = 2
        	scrollFrame.Parent = frame

        	-- Function to update canvas size (USING OLD UI.LUA LOGIC - Line ~692)
        	local updateCanvasSize  -- Forward declaration

        	updateCanvasSize = function()
        		-- Calculate actual content height for the active tab only
        		local maxY = 10

        		-- Find the currently visible tab content frame
        		local activeTabContent = nil
        		for _, child in ipairs(scrollFrame:GetChildren()) do
        			if child:IsA("Frame") and child.Visible then
        				activeTabContent = child
        				break
        			end
        		end

        		if activeTabContent then
        			-- Calculate content height within the active tab
        			for _, child in ipairs(activeTabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childY = child.Position.Y.Offset
        					local childHeight = child.AbsoluteSize.Y
        					local childBottom = childY + childHeight

        					if childBottom > maxY then
        						maxY = childBottom
        					end
        				end
        			end
        		end

        		-- Set canvas size with padding
        		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, maxY + 20)
        	end

        	-- Dragging functionality
        	if draggable then
        		local dragging = false
        		local dragInput, dragStart, startPos

        		local function update(input)
        			local delta = input.Position - dragStart
        			frame.Position = UDim2.new(
        				startPos.X.Scale,
        				startPos.X.Offset + delta.X,
        				startPos.Y.Scale,
        				startPos.Y.Offset + delta.Y
        			)
        		end

        		titleBar.InputBegan:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragging = true
        				dragStart = input.Position
        				startPos = frame.Position

        				input.Changed:Connect(function()
        					if input.UserInputState == Enum.UserInputState.End then
        						dragging = false
        					end
        				end)
        			end
        		end)

        		titleBar.InputChanged:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseMovement or
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragInput = input
        			end
        		end)

        		game:GetService("UserInputService").InputChanged:Connect(function(input)
        			if dragging and input == dragInput then
        				update(input)
        			end
        		end)
        	end

        	-- Resize functionality
        	local resizeHandle = nil
        	if resizable then
        		resizeHandle = self:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	end

        	-- Tab panel resize functionality
        	local tabPanelResizer = nil
        	if tabPanelResizable then
        		tabPanelResizer = self:CreateTabPanelResizer(tabPanel, scrollFrame, minTabPanelWidth, maxTabPanelWidth)
        	end

        	-- Monitor frame size changes and update canvas
        	frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        		-- Update canvas size when window is resized
        		task.spawn(updateCanvasSize)
        	end)

        	-- Tab management
        	local tabs = {}
        	local tabContents = {}
        	local currentTab = nil
        	local tabCount = 0
        	local originalHeight = windowHeight
        	local originalPosition = frame.Position

        	-- Setup minimize/restore functionality (create control first)
        	local minimizeControl = {
        		Toggle = nil,
        		IsMinimized = nil
        	}

        	-- Create floating button with toggle callback
        	local floatingButton = self:CreateFloatingButton(screenGui, frame, function()
        		if minimizeControl.Toggle then
        			minimizeControl.Toggle()
        		end
        	end, autoShow)

        	-- Now create the actual minimize control
        	local actualMinimizeControl = self:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	minimizeControl.Toggle = actualMinimizeControl.Toggle
        	minimizeControl.IsMinimized = actualMinimizeControl.IsMinimized

        	-- Connect minimize button
        	minimizeBtn.MouseButton1Click:Connect(minimizeControl.Toggle)

        	-- Keyboard shortcut for toggle minimize (Ctrl + M or Ctrl + H)
        	local UserInputService = game:GetService("UserInputService")
        	UserInputService.InputBegan:Connect(function(input, gameProcessed)
        		-- Don't trigger if user is typing in a text box
        		if gameProcessed then return end

        		-- Check for Ctrl + M or Ctrl + H
        		if input.KeyCode == Enum.KeyCode.M or input.KeyCode == Enum.KeyCode.H then
        			if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
        			   UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
        				minimizeControl.Toggle()
        			end
        		end
        	end)

        	-- Initialize Notification component
        	if Notification then
        		Notification:Init(Colors)
        	end

        	-- Window API
        	local windowAPI = {
        		ScreenGui = screenGui,
        		Frame = frame,
        		TitleBar = titleBar,
        		TabScrollFrame = tabScrollFrame,
        		ScrollFrame = scrollFrame,
        		TabPanel = tabPanel,
        		FloatingButton = floatingButton.Frame,
        		ResizeHandle = resizeHandle,
        		TabPanelResizer = tabPanelResizer,
        		UpdateCanvasSize = updateCanvasSize,  -- Expose update function for accordion callbacks
        		Notification = Notification, -- Expose notification component
        	}

        	function windowAPI:Show()
        		-- Show the window
        		frame.Visible = true
        		-- Hide the floating button when window is shown
        		floatingButton.Frame.Visible = false
        		-- If window was minimized, restore it
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Hide()
        		-- Hide the window
        		frame.Visible = false
        		-- Show the floating button when window is hidden
        		floatingButton.Frame.Visible = true
        	end

        	function windowAPI:IsVisible()
        		-- Check if the window is currently visible (not minimized)
        		return frame.Visible and not minimizeControl.IsMinimized()
        	end

        	function windowAPI:ToggleVisibility()
        		-- Toggle window visibility
        		if self:IsVisible() then
        			self:Hide()
        		else
        			self:Show()
        		end
        		return self:IsVisible()
        	end

        	function windowAPI:Toggle()
        		return self:ToggleVisibility()
        	end

        	function windowAPI:Minimize()
        		if not minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Restore()
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:ToggleMinimize()
        		minimizeControl.Toggle()
        	end

        	function windowAPI:IsMinimized()
        		return minimizeControl.IsMinimized()
        	end

        	function windowAPI:Destroy()
        		screenGui:Destroy()
        	end

        	function windowAPI:SetTitle(newTitle)
        		titleLabel.Text = newTitle
        		title = newTitle
        	end

        	function windowAPI:SetSize(newWidth, newHeight)
        		windowWidth = newWidth
        		originalHeight = newHeight
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        	end

        	function windowAPI:SetPosition(x, y)
        		frame.Position = UDim2.new(0, x, 0, y)
        	end

        	function windowAPI:Center()
        		local viewportSize = Window:GetViewportSize()
        		local size = frame.AbsoluteSize
        		frame.Position = UDim2.new(
        			0, (viewportSize.X - size.X) / 2,
        			0, (viewportSize.Y - size.Y) / 2
        		)
        	end

        	function windowAPI:SetResizable(enabled)
        		if resizeHandle then
        			resizeHandle.Visible = enabled
        		end
        	end

        	function windowAPI:GetSize()
        		return frame.AbsoluteSize
        	end

        	function windowAPI:SetTabPanelWidth(newWidth)
        		newWidth = math.max(minTabPanelWidth, math.min(maxTabPanelWidth, newWidth))
        		tabPanel.Size = UDim2.new(0, newWidth, 1, -30)
        		scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        		scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        	end

        	function windowAPI:GetTabPanelWidth()
        		return tabPanel.AbsoluteSize.X
        	end

        	function windowAPI:SetTabPanelResizable(enabled)
        		if tabPanelResizer then
        			tabPanelResizer.Visible = enabled
        		end
        	end

        	function windowAPI:GetTabs()
        		return tabs
        	end

        	function windowAPI:GetCurrentTab()
        		return currentTab
        	end

        	function windowAPI:SelectTab(index)
        		if tabs[index] then
        			if currentTab then
        				currentTab:Deselect()
        			end
        			currentTab = tabs[index]
        			currentTab:Select()
        		end
        	end

        	function windowAPI:AddTab(config)
        		-- Handle string shortcut
        		if type(config) == "string" then
        			config = {Name = config}
        		end

        		-- Validate config
        		if type(config) ~= "table" then
        			return nil
        		end

        		local tabName = config.Name or "Tab " .. (tabCount + 1)
        		local icon = config.Icon or ""

        		-- Create the tab using Tab component
        		local tabConfig = {
        			Name = tabName,
        			Icon = icon,
        			TabScrollFrame = tabScrollFrame,
        			TabContents = tabContents,
        			ScrollFrame = scrollFrame,
        			ScreenGui = screenGui,
        			WindowAPI = windowAPI,  -- Pass window API reference for accordion canvas updates
        			UpdateCanvasSize = updateCanvasSize,  -- Pass canvas update function
        			Settings = settings  -- Optional settings for the tab
        		}

        		local tabAPI = Tab:Create(tabConfig)

        		if not tabAPI then
        			return nil
        		end

        		-- Add click handler to switch tabs
        		tabAPI.Button.MouseButton1Click:Connect(function()
        			if currentTab and currentTab ~= tabAPI then
        				currentTab:Deselect()
        			end
        			currentTab = tabAPI
        			tabAPI:Select()
        		end)

        		-- Store tab reference
        		tabCount = tabCount + 1
        		tabs[tabCount] = tabAPI

        		-- Auto-select first tab
        		if tabCount == 1 then
        			currentTab = tabAPI
        			tabAPI:Select()
        		end

        		-- Update tab scroll canvas size
        		tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y)

        		return tabAPI
        	end

        	-- Notification methods
        	function windowAPI:ShowNotification(config)
        		if not Notification then
        			return nil
        		end
        		config = config or {}
        		config.ScreenGui = screenGui
        		return Notification:Create(config)
        	end

        	function windowAPI:ShowSuccess(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "success",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowWarning(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "warning",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowError(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "error",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowInfo(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "info",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:DismissNotification(id)
        		if Notification then
        			Notification:Dismiss(id)
        		end
        	end

        	function windowAPI:ClearNotifications()
        		if Notification then
        			Notification:Clear()
        		end
        	end

        	function windowAPI:GetConfigValue(key)
        		return settings:GetValue(key)
        	end

        	function windowAPI:SetConfigValue(key, value)
        		settings:SetValue(key, value)
        	end

        	-- Viewport adaptation methods
        	function windowAPI:AdaptToViewport()
        		-- Recalculate window size based on current viewport
        		local currentViewport = self:GetViewportSize()
        		local baseWidth = config.Width or (currentViewport.X * 0.3)
        		local baseHeight = config.Height or (currentViewport.Y * 0.4)

        		-- Apply resolution-based scaling
        		local scaleMultiplier = 1
        		if currentViewport.X >= 1920 then -- 1080p+
        			scaleMultiplier = 1.2
        		elseif currentViewport.X >= 1366 then -- 720p-1080p
        			scaleMultiplier = 1.0
        		elseif currentViewport.X >= 1024 then -- Tablet size
        			scaleMultiplier = 0.9
        		else -- Mobile/small screens
        			scaleMultiplier = 0.8
        		end

        		-- Calculate new size with limits
        		local newWidth = math.max(250, math.min(currentViewport.X * 0.8, baseWidth * scaleMultiplier))
        		local newHeight = math.max(150, math.min(currentViewport.Y * 0.8, baseHeight * scaleMultiplier))

        		-- Apply new size and center the window
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
        	end

        	function windowAPI:GetDynamicSize()
        		local currentViewport = self:GetViewportSize()
        		return {
        			Width = frame.Size.X.Offset,
        			Height = frame.Size.Y.Offset,
        			ViewportWidth = currentViewport.X,
        			ViewportHeight = currentViewport.Y
        		}
        	end

        	function windowAPI:SetSize(width, height)
        		local viewportSize = self:GetViewportSize()

        		-- Apply constraints
        		width = math.max(300, math.min(width, viewportSize.X * 0.9))
        		height = math.max(200, math.min(height, viewportSize.Y * 0.9))

        		frame.Size = UDim2.new(0, width, 0, height)

        		return {Width = width, Height = height}
        	end

        	-- Close callback functionality
        	function windowAPI:SetCloseCallback(callback)
        		onCloseCallback = callback
        	end

        	function windowAPI:Close()
        		-- Call user callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        			end
        		end

        		-- Destroy the UI
        		if screenGui then
        			screenGui:Destroy()
        		end
        	end

        	-- Auto-adapt to viewport changes (optional)
        	if autoAdapt then
        		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        			task.wait(0.1) -- Small delay to ensure viewport is stable
        			windowAPI:AdaptToViewport()
        		end)
        	end

        	return windowAPI
        end

        return Window

    end

    -- Module: utils/colors
    EmbeddedModules["utils/colors"] = function()
        --[[
        	EzUI Color Palette Module
        	Dark Mode Color Scheme for Roblox GUI

        	Author: EzUI Library
        	Version: 1.0.0

        	Usage:
        		local m = require(path.to.color)
        		myFrame.BackgroundColor3 = Colors.Background.Primary
        		myButton.BackgroundColor3 = Colors.Button.Default
        ]]

        local Colors = {}

        -- ============================================
        -- BACKGROUND COLORS
        -- ============================================
        Colors.Background = {
        	Primary = Color3.fromRGB(30, 30, 35),      -- Main background
        	Secondary = Color3.fromRGB(40, 40, 45),    -- Secondary panels
        	Tertiary = Color3.fromRGB(50, 50, 55),     -- Elevated elements
        	Overlay = Color3.fromRGB(20, 20, 25),      -- Modal overlays
        	Transparent = Color3.fromRGB(0, 0, 0),     -- For transparent elements
        }

        -- ============================================
        -- SURFACE COLORS (Components)
        -- ============================================
        Colors.Surface = {
        	Default = Color3.fromRGB(45, 45, 50),      -- Default surface
        	Elevated = Color3.fromRGB(55, 55, 60),     -- Elevated surface
        	Hover = Color3.fromRGB(60, 60, 65),        -- Hover state
        	Active = Color3.fromRGB(65, 65, 70),       -- Active/Pressed state
        	Disabled = Color3.fromRGB(35, 35, 40),     -- Disabled state
        }

        -- ============================================
        -- TEXT COLORS
        -- ============================================
        Colors.Text = {
        	Primary = Color3.fromRGB(255, 255, 255),   -- Primary text (high contrast)
        	Secondary = Color3.fromRGB(200, 200, 205), -- Secondary text (medium contrast)
        	Tertiary = Color3.fromRGB(150, 150, 155),  -- Tertiary text (low contrast)
        	Disabled = Color3.fromRGB(100, 100, 105),  -- Disabled text
        	Placeholder = Color3.fromRGB(120, 120, 125), -- Placeholder text
        	Link = Color3.fromRGB(100, 150, 255),      -- Link text
        	LinkHover = Color3.fromRGB(120, 170, 255), -- Link hover
        }

        -- ============================================
        -- BORDER COLORS
        -- ============================================
        Colors.Border = {
        	Default = Color3.fromRGB(80, 80, 85),      -- Default border
        	Light = Color3.fromRGB(100, 100, 105),     -- Light border
        	Dark = Color3.fromRGB(60, 60, 65),         -- Dark border
        	Focus = Color3.fromRGB(100, 150, 255),     -- Focused border
        	Error = Color3.fromRGB(255, 100, 100),     -- Error border
        	Success = Color3.fromRGB(100, 255, 150),   -- Success border
        }

        -- ============================================
        -- BUTTON COLORS
        -- ============================================
        Colors.Button = {
        	-- Primary Button
        	Primary = Color3.fromRGB(100, 150, 255),
        	PrimaryHover = Color3.fromRGB(120, 170, 255),
        	PrimaryActive = Color3.fromRGB(80, 130, 235),
        	PrimaryDisabled = Color3.fromRGB(60, 90, 150),

        	-- Secondary Button
        	Secondary = Color3.fromRGB(80, 80, 90),
        	SecondaryHover = Color3.fromRGB(100, 100, 110),
        	SecondaryActive = Color3.fromRGB(70, 70, 80),
        	SecondaryDisabled = Color3.fromRGB(50, 50, 60),

        	-- Success Button
        	Success = Color3.fromRGB(76, 175, 80),
        	SuccessHover = Color3.fromRGB(96, 195, 100),
        	SuccessActive = Color3.fromRGB(56, 155, 60),
        	SuccessDisabled = Color3.fromRGB(46, 115, 50),

        	-- Danger Button
        	Danger = Color3.fromRGB(244, 67, 54),
        	DangerHover = Color3.fromRGB(255, 87, 74),
        	DangerActive = Color3.fromRGB(224, 47, 34),
        	DangerDisabled = Color3.fromRGB(150, 40, 35),

        	-- Warning Button
        	Warning = Color3.fromRGB(255, 193, 7),
        	WarningHover = Color3.fromRGB(255, 213, 27),
        	WarningActive = Color3.fromRGB(235, 173, 0),
        	WarningDisabled = Color3.fromRGB(150, 120, 10),
        }

        -- ============================================
        -- INPUT COLORS (TextBox, SelectBox, etc)
        -- ============================================
        Colors.Input = {
        	Background = Color3.fromRGB(60, 60, 65),
        	BackgroundHover = Color3.fromRGB(70, 70, 75),
        	BackgroundFocus = Color3.fromRGB(65, 65, 70),
        	BackgroundDisabled = Color3.fromRGB(45, 45, 50),
        	Border = Color3.fromRGB(100, 100, 105),
        	BorderFocus = Color3.fromRGB(100, 150, 255),
        	BorderError = Color3.fromRGB(255, 100, 100),
        	Text = Color3.fromRGB(255, 255, 255),
        	Placeholder = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- TOGGLE/SWITCH COLORS
        -- ============================================
        Colors.Toggle = {
        	On = Color3.fromRGB(76, 175, 80),
        	Off = Color3.fromRGB(100, 100, 100),
        	Handle = Color3.fromRGB(255, 255, 255),
        	Disabled = Color3.fromRGB(70, 70, 75),
        }

        -- ============================================
        -- SLIDER COLORS
        -- ============================================
        Colors.Slider = {
        	Track = Color3.fromRGB(80, 80, 85),
        	TrackFilled = Color3.fromRGB(100, 150, 255),
        	Handle = Color3.fromRGB(255, 255, 255),
        	HandleHover = Color3.fromRGB(245, 245, 245),
        	HandleActive = Color3.fromRGB(230, 230, 230),
        	HandleDisabled = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- DROPDOWN COLORS
        -- ============================================
        Colors.Dropdown = {
        	Background = Color3.fromRGB(45, 45, 50),
        	Option = Color3.fromRGB(50, 50, 55),
        	OptionHover = Color3.fromRGB(70, 70, 75),
        	OptionSelected = Color3.fromRGB(70, 120, 70),
        	OptionActive = Color3.fromRGB(100, 150, 255),
        	Border = Color3.fromRGB(150, 150, 155),
        	Arrow = Color3.fromRGB(200, 200, 205),
        }

        -- ============================================
        -- SCROLLBAR COLORS
        -- ============================================
        Colors.Scrollbar = {
        	Background = Color3.fromRGB(40, 40, 45),
        	Thumb = Color3.fromRGB(120, 120, 125),
        	ThumbHover = Color3.fromRGB(140, 140, 145),
        	ThumbActive = Color3.fromRGB(160, 160, 165),
        }

        -- ============================================
        -- STATUS COLORS (Semantic m)
        -- ============================================
        Colors.Status = {
        	Success = Color3.fromRGB(76, 175, 80),
        	Warning = Color3.fromRGB(255, 193, 7),
        	Error = Color3.fromRGB(244, 67, 54),
        	Info = Color3.fromRGB(33, 150, 243),
        }

        -- ============================================
        -- ACCENT COLORS
        -- ============================================
        Colors.Accent = {
        	Primary = Color3.fromRGB(100, 150, 255),   -- Blue
        	Secondary = Color3.fromRGB(156, 39, 176),  -- Purple
        	Success = Color3.fromRGB(76, 175, 80),     -- Green
        	Warning = Color3.fromRGB(255, 193, 7),     -- Yellow
        	Danger = Color3.fromRGB(244, 67, 54),      -- Red
        	Info = Color3.fromRGB(33, 150, 243),       -- Light Blue
        }

        -- ============================================
        -- SPECIAL COLORS
        -- ============================================
        Colors.Special = {
        	Shadow = Color3.fromRGB(0, 0, 0),          -- For shadows
        	Highlight = Color3.fromRGB(255, 255, 255), -- For highlights
        	Overlay = Color3.fromRGB(0, 0, 0),         -- For modal overlays (use with transparency)
        	Divider = Color3.fromRGB(80, 80, 85),      -- For separators/dividers
        }

        -- ============================================
        -- TAB COLORS
        -- ============================================
        Colors.Tab = {
        	Background = Color3.fromRGB(50, 50, 50),
        	BackgroundHover = Color3.fromRGB(60, 60, 60),
        	BackgroundActive = Color3.fromRGB(70, 70, 75),
        	Text = Color3.fromRGB(255, 255, 255),
        	TextInactive = Color3.fromRGB(180, 180, 185),
        	Indicator = Color3.fromRGB(100, 150, 255),
        }

        -- ============================================
        -- NOTIFICATION COLORS
        -- ============================================
        Colors.Notification = {
        	Success = {
        		Background = Color3.fromRGB(46, 125, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(76, 175, 80),
        	},
        	Warning = {
        		Background = Color3.fromRGB(245, 127, 23),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(255, 193, 7),
        	},
        	Error = {
        		Background = Color3.fromRGB(211, 47, 47),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(244, 67, 54),
        	},
        	Info = {
        		Background = Color3.fromRGB(25, 118, 210),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(33, 150, 243),
        	},
        }

        -- ============================================
        -- UTILITY FUNCTIONS
        -- ============================================

        -- Convert Color3 to hex string
        function Colors:ToHex(color3)
        	local r = math.floor(color3.R * 255)
        	local g = math.floor(color3.G * 255)
        	local b = math.floor(color3.B * 255)
        	return string.format("#%02X%02X%02X", r, g, b)
        end

        -- Convert hex string to Color3
        function Colors:FromHex(hex)
        	hex = hex:gsub("#", "")
        	local r = tonumber("0x" .. hex:sub(1, 2)) / 255
        	local g = tonumber("0x" .. hex:sub(3, 4)) / 255
        	local b = tonumber("0x" .. hex:sub(5, 6)) / 255
        	return Color3.new(r, g, b)
        end

        -- Lighten a color by a percentage (0-1)
        function Colors:Lighten(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Darken a color by a percentage (0-1)
        function Colors:Darken(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v - amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Adjust saturation of a color
        function Colors:Saturate(color3, amount)
        	amount = math.clamp(amount, -1, 1)
        	local h, s, v = color3:ToHSV()
        	s = math.clamp(s + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Mix two colors with a ratio (0 = color1, 1 = color2)
        function Colors:Mix(color1, color2, ratio)
        	ratio = math.clamp(ratio, 0, 1)
        	return Color3.new(
        		color1.R + (color2.R - color1.R) * ratio,
        		color1.G + (color2.G - color1.G) * ratio,
        		color1.B + (color2.B - color1.B) * ratio
        	)
        end

        -- Get contrasting text color (black or white) based on background
        function Colors:GetContrastText(backgroundColor)
        	local luminance = (0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B)
        	return luminance > 0.5 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
        end

        -- Apply alpha/transparency to a color (returns color and transparency value)
        function Colors:WithAlpha(color3, alpha)
        	alpha = math.clamp(alpha, 0, 1)
        	return color3, 1 - alpha
        end

        -- Create a gradient of colors
        function Colors:CreateGradient(startColor, endColor, steps)
        	local gradient = {}
        	for i = 0, steps - 1 do
        		local ratio = i / (steps - 1)
        		table.insert(gradient, Colors.Mix(startColor, endColor, ratio))
        	end
        	return gradient
        end

        -- ============================================
        -- PRESET THEMES
        -- ============================================
        Colors.Themes = {
        	-- Default Dark Theme (already defined above)
        	Dark = {
        		Name = "Dark",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(30, 30, 35),
        		Surface = Color3.fromRGB(45, 45, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Darker Theme
        	Darker = {
        		Name = "Darker",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(15, 15, 20),
        		Surface = Color3.fromRGB(25, 25, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Blue Dark Theme
        	BlueDark = {
        		Name = "Blue Dark",
        		Primary = Color3.fromRGB(33, 150, 243),
        		Background = Color3.fromRGB(18, 32, 47),
        		Surface = Color3.fromRGB(28, 42, 57),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Purple Dark Theme
        	PurpleDark = {
        		Name = "Purple Dark",
        		Primary = Color3.fromRGB(156, 39, 176),
        		Background = Color3.fromRGB(30, 20, 35),
        		Surface = Color3.fromRGB(45, 30, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Green Dark Theme
        	GreenDark = {
        		Name = "Green Dark",
        		Primary = Color3.fromRGB(76, 175, 80),
        		Background = Color3.fromRGB(20, 30, 20),
        		Surface = Color3.fromRGB(30, 45, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},
        }

        -- ============================================
        -- RETURN MODULE
        -- ============================================
        return Colors

    end

    -- Module: utils/config
    EmbeddedModules["utils/config"] = function()
        local Config = {}
        local HttpService = game:GetService("HttpService")

        function Config:NewConfig(config)
        	-- Support both old style (string, string) and new style (table)
        	local configName, directory

        	if type(config) == "table" then
        		-- New style: table parameter
        		configName = config.ConfigName or config.FileName or config.Name
        		directory = config.Directory or config.FolderName
        	elseif type(config) == "string" then
        		-- Old style: first parameter is configName
        		configName = config
        		directory = nil
        	else
        		return nil
        	end

        	if not configName or type(configName) ~= "string" then
        		return nil
        	end

        	-- Use custom directory or default to EzUI Configuration folder
        	local customDirectory = directory
        	if customDirectory and type(customDirectory) ~= "string" then
        		customDirectory = nil
        	end

        	-- Create independent storage for this custom config
        	local Flags = {}

        	-- Save function for this custom config
        	local function SaveConfiguration()

        		-- Filter out keys with nil values
        		local dataToSave = {}
        		local hasData = false

        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				dataToSave[key] = value
        				hasData = true
        			end
        		end

        		if not hasData then
        			return false
        		end

        		if not writefile or not isfolder or not makefolder then
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local dynamicFolderName, dynamicConfigurationFolder, filePath

        		if customDirectory then
        			-- Custom directory path
        			dynamicFolderName = customDirectory
        			dynamicConfigurationFolder = customDirectory
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		-- Create folders if they don't exist
        		if not isfolder(dynamicFolderName) then
        			makefolder(dynamicFolderName)
        		end

        		-- Only create Configurations subfolder if not using custom directory
        		if not customDirectory and not isfolder(dynamicConfigurationFolder) then
        			makefolder(dynamicConfigurationFolder)
        		end

        		-- Save to JSON file
        		local success, result = pcall(function()
        			writefile(filePath, HttpService:JSONEncode(dataToSave))
        		end)

        		if success then
        			local savedCount = 0
        			for _ in pairs(dataToSave) do
        				savedCount = savedCount + 1
        			end
        			return true
        		else
        			return false
        		end
        	end

        	-- Load function for this custom config
        	local function LoadConfiguration()
        		if not readfile or not isfile then
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local filePath

        		if customDirectory then
        			-- Custom directory path
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		if not isfile(filePath) then
        			return false
        		end

        		local success, configData = pcall(function()
        			-- Decode JSON data
        			return HttpService:JSONDecode(readfile(filePath))
        		end)

        		if not success then
        			return false
        		end

        		-- Apply loaded data and update components
        		local applied = 0
        		for flagName, flagValue in pairs(configData) do
        			Flags[flagName] = flagValue
        			applied = applied + 1
        		end

        		return true
        	end

        	local configAPI = {}

        	-- Get value by key
        	function configAPI:GetValue(key)
        		if not key then
        			return nil
        		end
        		return Flags[key]
        	end

        	-- Set value by key and update associated components
        	function configAPI:SetValue(key, value)
        		if not key then
        			return false
        		end


        		Flags[key] = value

        		SaveConfiguration()
        		return true
        	end

        	-- Get all key-value pairs
        	function configAPI:GetAll()
        		local result = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				result[key] = value
        			end
        		end
        		return result
        	end

        	-- Get All Keys
        	function configAPI:GetAllKeys()
        		local keys = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				table.insert(keys, key)
        			end
        		end
        		return keys
        	end

        	-- Delete a specific key
        	function configAPI:DeleteKey(key)
        		if not key then
        			return false
        		end

        		if Flags[key] ~= nil then
        			Flags[key] = nil

        			SaveConfiguration()
        			return true
        		else
        			return false
        		end
        	end

        	-- Get configuration info
        	function configAPI:GetInfo()
        		local folderName, configFolder, filePath

        		if customDirectory then
        			folderName = customDirectory
        			configFolder = customDirectory
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			folderName = EzUI.Configuration.FolderName or "EzUI"
        			configFolder = folderName .. "/Configurations"
        			filePath = configFolder .. "/" .. configName .. ".json"
        		end

        		return {
        			ConfigName = configName,
        			CustomDirectory = customDirectory,
        			FolderName = folderName,
        			ConfigFolder = configFolder,
        			FilePath = filePath,
        			IsCustomDirectory = customDirectory ~= nil
        		}
        	end

        	-- Manual save
        	function configAPI:Save()
        		return SaveConfiguration()
        	end

        	-- Manual load
        	function configAPI:Load()
        		return LoadConfiguration()
        	end

        	-- Return custom configuration object
        	return configAPI
        end

        return Config
    end

    -- Module: components/accordion
    EmbeddedModules["components/accordion"] = function()
        --[[
        	Accordion Component
        	EzUI Library - Modular Component

        	Creates a collapsible accordion with dynamic content
        	Uses proven logic from old ui.lua for reliable expand/collapse behavior
        ]]

        -- Component modules (will be loaded by Window)
        local Accordion = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator

        -- Initialize component modules
        function Accordion:Init(_colors, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Accordion:Create(config)
        	-- Configuration
        	local title = config.Title or config.Name or "Accordion"
        	local expanded = config.Expanded or config.Open or config.DefaultExpanded or false
        	local icon = config.Icon or ""
        	local tabContent = config.Parent
        	local accordionStartY = config.Y or 0

        	-- Accordion state
        	local isExpanded = expanded
        	local callback = config.Callback -- function dipanggil saat expand/collapse/toggle
        	local accordionContentHeight = 0

        	-- Main accordion container
        	local accordionContainer = Instance.new("Frame")
        	accordionContainer.Size = UDim2.new(1, -20, 0, 30) -- Initial height just for header
        	accordionContainer.Position = UDim2.new(0, 10, 0, accordionStartY)
        	accordionContainer.BackgroundTransparency = 1
        	accordionContainer.ClipsDescendants = false -- Allow content to show
        	accordionContainer.ZIndex = 3
        	accordionContainer.Parent = tabContent

        	-- Store reference to this accordion
        	accordionContainer:SetAttribute("AccordionStartY", accordionStartY)
        	accordionContainer:SetAttribute("IsAccordion", true)

        	-- Accordion header (clickable)
        	local accordionHeader = Instance.new("TextButton")
        	accordionHeader.Size = UDim2.new(1, 0, 0, 30)
        	accordionHeader.Position = UDim2.new(0, 0, 0, 0)
        	accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	accordionHeader.BorderSizePixel = 0
        	accordionHeader.Text = ""
        	accordionHeader.ZIndex = 4
        	accordionHeader.Parent = accordionContainer

        	-- Header round corners
        	local headerCorner = Instance.new("UICorner")
        	headerCorner.CornerRadius = UDim.new(0, 4)
        	headerCorner.Parent = accordionHeader

        	-- Expand/Collapse arrow
        	local accordionArrow = Instance.new("TextLabel")
        	accordionArrow.Size = UDim2.new(0, 30, 1, 0)
        	accordionArrow.Position = UDim2.new(0, 5, 0, 0)
        	accordionArrow.BackgroundTransparency = 1
        	accordionArrow.Text = isExpanded and "▼" or "►"
        	accordionArrow.TextColor3 = Colors.Text.Secondary
        	accordionArrow.TextSize = 12
        	accordionArrow.Font = Enum.Font.SourceSansBold
        	accordionArrow.ZIndex = 5
        	accordionArrow.Parent = accordionHeader

        	-- Icon (optional)
        	local accordionIcon = Instance.new("TextLabel")
        	accordionIcon.Size = UDim2.new(0, 25, 1, 0)
        	accordionIcon.Position = UDim2.new(0, 30, 0, 0)
        	accordionIcon.BackgroundTransparency = 1
        	accordionIcon.Text = icon
        	accordionIcon.TextColor3 = Colors.Text.Primary
        	accordionIcon.TextXAlignment = Enum.TextXAlignment.Center
        	accordionIcon.Font = Enum.Font.SourceSans
        	accordionIcon.TextSize = 14
        	accordionIcon.ZIndex = 5
        	accordionIcon.Parent = accordionHeader

        	-- Accordion title
        	local accordionTitle = Instance.new("TextLabel")
        	accordionTitle.Size = UDim2.new(1, -70, 1, 0)
        	accordionTitle.Position = UDim2.new(0, 60, 0, 0)
        	accordionTitle.BackgroundTransparency = 1
        	accordionTitle.Text = title
        	accordionTitle.TextColor3 = Colors.Text.Primary
        	accordionTitle.TextXAlignment = Enum.TextXAlignment.Left
        	accordionTitle.Font = Enum.Font.SourceSansBold
        	accordionTitle.TextSize = 14
        	accordionTitle.ZIndex = 5
        	accordionTitle.Parent = accordionHeader

        	-- Accordion content container (no scroll)
        	local accordionContent = Instance.new("Frame")
        	accordionContent.Size = UDim2.new(1, 0, 0, 0) -- Start with 0 height
        	accordionContent.Position = UDim2.new(0, 0, 0, 32) -- Below header
        	accordionContent.BackgroundColor3 = Colors.Background.Tertiary
        	accordionContent.BorderSizePixel = 0
        	accordionContent.Visible = isExpanded
        	accordionContent.ClipsDescendants = false -- Don't clip content
        	accordionContent.ZIndex = 4
        	accordionContent.Parent = accordionContainer

        	-- Round corners for content
        	local contentCorner = Instance.new("UICorner")
        	contentCorner.CornerRadius = UDim.new(0, 4)
        	contentCorner.Parent = accordionContent

        	-- Add padding to accordion content
        	local contentPadding = Instance.new("UIPadding")
        	contentPadding.PaddingTop = UDim.new(0, 5)
        	contentPadding.PaddingBottom = UDim.new(0, 5)
        	contentPadding.PaddingLeft = UDim.new(0, 5)
        	contentPadding.PaddingRight = UDim.new(0, 5)
        	contentPadding.Parent = accordionContent

        	-- Content layout
        	local contentLayout = Instance.new("UIListLayout")
        	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	contentLayout.Padding = UDim.new(0, 5)
        	contentLayout.Parent = accordionContent

        	-- Track layout order for accordion content (UIListLayout handles actual positioning)
        	local accordionCurrentY = 1

        	-- Function to update positions of all components below this accordion (FROM UI.LUA)
        	local function updateComponentsBelow()
        		-- Get current accordion bottom position
        		local accordionBottom = accordionContainer.Position.Y.Offset + accordionContainer.Size.Y.Offset

        		-- Create a list of all components with their Y positions
        		local components = {}
        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				-- Check if this component has a stored start Y position
        				local componentStartY = child:GetAttribute("ComponentStartY")
        				if componentStartY and componentStartY > accordionStartY then
        					table.insert(components, {
        						component = child,
        						originalY = componentStartY,
        						currentY = child.Position.Y.Offset
        					})
        				end
        			end
        		end

        		-- Sort components by their original Y position
        		table.sort(components, function(a, b)
        			return a.originalY < b.originalY
        		end)

        		-- Update positions of components that come after this accordion
        		local nextY = accordionBottom + 5
        		for _, componentData in ipairs(components) do
        			componentData.component.Position = UDim2.new(0, 10, 0, nextY)
        			-- Add the component's height to calculate next position
        			nextY = nextY + componentData.component.Size.Y.Offset + 5
        		end
        	end

        	-- Function to recalculate total tab height (FROM UI.LUA)
        	local function recalculateTabHeight()
        		-- Wait to ensure all size updates are rendered
        		task.wait()

        		-- Callback to parent tab to recalculate
        		if config.OnHeightChanged then
        			config.OnHeightChanged()
        		end
        	end

        	-- Function to update accordion container size (FROM UI.LUA)
        	local function updateAccordionSize()
        		-- Get the actual content size from UIListLayout
        		local actualContentHeight = contentLayout.AbsoluteContentSize.Y + 20 -- Add padding
        		accordionContentHeight = actualContentHeight

        		-- Update accordion container size
        		local totalHeight = 35 + (isExpanded and accordionContentHeight or 0)
        		accordionContainer.Size = UDim2.new(1, -20, 0, totalHeight)

        		-- Update accordion content frame size
        		if isExpanded then
        			accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		end

        		-- Update positions of components below
        		updateComponentsBelow()

        		-- Recalculate total tab height
        		recalculateTabHeight()
        	end

        	-- Auto-update accordion size when content layout changes (now that updateAccordionSize is defined)
        	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        		-- Always update the content height, regardless of expanded state
        		updateAccordionSize()
        	end)

        	-- Animation function for smooth expand/collapse (FROM UI.LUA)
        	local function animateAccordion()
        		local TweenService = game:GetService("TweenService")

        		-- Calculate sizes BEFORE any changes
        		local oldContainerHeight = accordionContainer.Size.Y.Offset
        		local targetContentHeight = isExpanded and accordionContentHeight or 0
        		local targetContainerHeight = 35 + targetContentHeight
        		local heightDifference = targetContainerHeight - oldContainerHeight

        		-- Store components that come after this accordion BEFORE size changes
        		local componentsBelow = {}
        		local accordionBottom = accordionContainer.Position.Y.Offset + oldContainerHeight

        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				local childY = child.Position.Y.Offset
        				if childY > accordionBottom then
        					table.insert(componentsBelow, {
        						component = child,
        						currentY = childY,
        						targetY = childY + heightDifference
        					})
        				end
        			end
        		end

        		-- Update arrow direction
        		accordionArrow.Text = isExpanded and "▼" or "►"

        		-- Show content immediately if expanding
        		if isExpanded then
        			accordionContent.Visible = true
        		end

        		-- Animate container size
        		local containerTween = TweenService:Create(
        			accordionContainer,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, -20, 0, targetContainerHeight)}
        		)

        		-- Animate content size
        		local contentTween = TweenService:Create(
        			accordionContent,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, 0, 0, targetContentHeight)}
        		)

        		-- Animate components below
        		for _, componentData in ipairs(componentsBelow) do
        			local componentTween = TweenService:Create(
        				componentData.component,
        				TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(0, 10, 0, componentData.targetY)}
        			)
        			componentTween:Play()
        		end

        		containerTween:Play()
        		contentTween:Play()

        		-- Handle animation completion
        		containerTween.Completed:Connect(function()
        			-- Hide content after collapse animation
        			if not isExpanded then
        				accordionContent.Visible = false
        			end

        			-- Wait for next frame to ensure sizes are updated
        			task.wait()

        			-- Recalculate total tab height
        			recalculateTabHeight()
        		end)
        	end

        	-- Header click handler
        	accordionHeader.MouseButton1Click:Connect(function()
        		isExpanded = not isExpanded
        		animateAccordion()
        	end)

        	-- Header hover effects
        	accordionHeader.MouseEnter:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	accordionHeader.MouseLeave:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Accordion control methods
        	function accordionAPI:Expand()
        		if not isExpanded then
        			isExpanded = true
        			animateAccordion()
        			if callback then callback(true) end -- true = dibuka
        		end
        	end

        	function accordionAPI:Collapse()
        		if isExpanded then
        			isExpanded = false
        			animateAccordion()
        			if callback then callback(false) end -- false = ditutup
        		end
        	end

        	function accordionAPI:Toggle()
        	isExpanded = not isExpanded
        	animateAccordion()
        	if callback then callback(isExpanded) end -- true/false
        	return isExpanded
        	end

        	function accordionAPI:IsExpanded()
        		return isExpanded
        	end

        	function accordionAPI:SetTitle(newTitle)
        		title = newTitle
        		accordionTitle.Text = newTitle
        	end

        	function accordionAPI:SetIcon(newIcon)
        		icon = newIcon
        		accordionIcon.Text = newIcon
        	end

        	function accordionAPI:GetHeight()
        		return accordionContainer.AbsoluteSize.Y
        	end

        	function accordionAPI:GetContentHeight()
        		return accordionContentHeight
        	end

        	-- Add Label method
        	function accordionAPI:AddLabel(labelConfig)
        		if not Label then return nil end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = accordionContent
        		lblConfig.Y = 0
        		lblConfig.IsForAccordion = true
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		if labelAPI and labelAPI.Label then
        			-- UIListLayout will handle positioning automatically
        			labelAPI.Label.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- Just increment counter for LayoutOrder
        		end

        		-- Update accordion size (the connection should handle this automatically)
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return labelAPI
        	end

        	-- Add Button method
        	function accordionAPI:AddButton(buttonConfig)
        		if not Button then return nil end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = accordionContent
        		btnConfig.Y = 0
        		btnConfig.IsForAccordion = true
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		if buttonAPI and buttonAPI.Button then
        			buttonAPI.Button.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return buttonAPI
        	end

        	-- Add Toggle method
        	function accordionAPI:AddToggle(toggleConfig)
        		if not Toggle then return nil end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = accordionContent
        		toggleConfig.Y = 0
        		toggleConfig.IsForAccordion = true
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		if toggleAPI and toggleAPI.Toggle then
        			toggleAPI.Toggle.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return toggleAPI
        	end

        	-- Add TextBox method
        	function accordionAPI:AddTextBox(textboxConfig)
        		if not TextBox then return nil end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = accordionContent
        		textboxConfig.Y = 0
        		textboxConfig.IsForAccordion = true
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)
        		if textboxAPI and textboxAPI.TextBox then
        			textboxAPI.TextBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return textboxAPI
        	end

        	-- Add NumberBox method
        	function accordionAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then return nil end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = accordionContent
        		numberboxConfig.Y = 0
        		numberboxConfig.IsForAccordion = true
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		if numberboxAPI and numberboxAPI.NumberBox then
        			numberboxAPI.NumberBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return numberboxAPI
        	end

        	-- Add SelectBox method
        	function accordionAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then return nil end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = accordionContent
        		selectboxConfig.Y = 0
        		selectboxConfig.IsForAccordion = true
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		if selectboxAPI and selectboxAPI.SelectBox then
        			selectboxAPI.SelectBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return selectboxAPI
        	end

        	-- Add Separator method
        	function accordionAPI:AddSeparator(separatorConfig)
        		if not Separator then return nil end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = accordionContent
        		separatorConfig.Y = 0
        		separatorConfig.IsForAccordion = true

        		local separatorAPI = Separator:Create(separatorConfig)
        		if separatorAPI and separatorAPI.Separator then
        			separatorAPI.Separator.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return separatorAPI
        	end

        	-- Initialize with expanded state
        	if isExpanded then
        		updateAccordionSize()
        		-- Don't animate on initial load, just set the size directly
        		accordionContainer.Size = UDim2.new(1, -20, 0, 35 + accordionContentHeight)
        		accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		accordionContent.Visible = true
        		accordionArrow.Text = "▼"
        	end

        	return accordionAPI
        end

        return Accordion

    end

    -- Module: components/button
    EmbeddedModules["components/button"] = function()
        --[[
        	Button Component
        	EzUI Library - Modular Component

        	Creates a clickable button with hover effects
        ]]
        local Button = {}

        local Colors

        function Button:Init(_colors)
        	Colors = _colors
        end

        function Button:Create(config)
        	local text = config.Text or config.Label or config.Title or config.Name or "Button"
        	local callback = config.Callback or function() end
        	local variant = config.Variant or "primary"
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Function to get variant colors
        	local function getVariantColors(variantName)
        		local variants = {
        			primary = {
        				background = Colors.Button.Primary,
        				backgroundHover = Colors.Button.PrimaryHover,
        				text = Colors.Text.Primary,
        				border = Colors.Text.Primary
        			},
        			secondary = {
        				background = Color3.fromRGB(108, 117, 125),
        				backgroundHover = Color3.fromRGB(90, 98, 104),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(108, 117, 125)
        			},
        			success = {
        				background = Color3.fromRGB(40, 167, 69),
        				backgroundHover = Color3.fromRGB(34, 142, 58),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(40, 167, 69)
        			},
        			warning = {
        				background = Color3.fromRGB(255, 193, 7),
        				backgroundHover = Color3.fromRGB(217, 164, 6),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(255, 193, 7)
        			},
        			danger = {
        				background = Color3.fromRGB(220, 53, 69),
        				backgroundHover = Color3.fromRGB(187, 45, 59),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(220, 53, 69)
        			},
        			info = {
        				background = Color3.fromRGB(13, 202, 240),
        				backgroundHover = Color3.fromRGB(11, 172, 204),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(13, 202, 240)
        			},
        			light = {
        				background = Color3.fromRGB(248, 249, 250),
        				backgroundHover = Color3.fromRGB(211, 212, 213),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(248, 249, 250)
        			},
        			dark = {
        				background = Color3.fromRGB(33, 37, 41),
        				backgroundHover = Color3.fromRGB(28, 31, 35),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(33, 37, 41)
        			}
        		}

        		return variants[variantName] or variants.primary
        	end

        	local variantColors = getVariantColors(variant)

        	local button = Instance.new("TextButton")
        	if isForAccordion then
        		-- Make button width responsive to content (takes full available width)
        		button.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion buttons - let UIListLayout handle it
        		button.BorderColor3 = variantColors.border
        		button.BorderSizePixel = 2
        		button.TextSize = 12
        		button.ZIndex = 5

        		-- Round corners for accordion button
        		local buttonCorner = Instance.new("UICorner")
        		buttonCorner.CornerRadius = UDim.new(0, 4)
        		buttonCorner.Parent = button

        		-- Button hover effects for accordion
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	else
        		button.Size = UDim2.new(0, 120, 0, 30)
        		button.Position = UDim2.new(0, 10, 0, currentY)
        		button.BorderSizePixel = 0
        		button.TextSize = 14
        		button.ZIndex = 3
        		button:SetAttribute("ComponentStartY", currentY)
        	end
        	button.BackgroundColor3 = variantColors.background
        	button.Text = text
        	button.TextColor3 = variantColors.text
        	button.Font = Enum.Font.SourceSans
        	button.TextScaled = false  -- Keep original text size
        	button.TextWrapped = false -- Don't wrap text to new lines
        	button.TextTruncate = Enum.TextTruncate.AtEnd -- Add ... at end if text is too long
        	button.Parent = parentContainer

        	-- Add hover effects for non-accordion buttons
        	if not isForAccordion then
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	end

        	if callback then
        		button.MouseButton1Click:Connect(callback)
        	end

        	-- Create Button API
        	local buttonAPI = {
        		Button = button
        	}

        	function buttonAPI:SetText(newText)
        		button.Text = newText or ""
        	end

        	function buttonAPI:GetText()
        		return button.Text
        	end

        	function buttonAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        		button.MouseButton1Click:Connect(callback)
        	end

        	function buttonAPI:SetEnabled(enabled)
        		button.Active = enabled
        		if enabled then
        			button.BackgroundColor3 = variantColors.background
        		else
        			-- Create a disabled version by reducing opacity/brightness
        			local r, g, b = variantColors.background.R, variantColors.background.G, variantColors.background.B
        			button.BackgroundColor3 = Color3.fromRGB(
        				math.floor(r * 255 * 0.5),
        				math.floor(g * 255 * 0.5),
        				math.floor(b * 255 * 0.5)
        			)
        		end
        	end

        	function buttonAPI:SetVariant(newVariant)
        		variant = newVariant or "primary"
        		variantColors = getVariantColors(variant)

        		-- Update button colors
        		button.BackgroundColor3 = variantColors.background
        		button.TextColor3 = variantColors.text
        		if isForAccordion then
        			button.BorderColor3 = variantColors.border
        		end
        	end

        	function buttonAPI:GetVariant()
        		return variant
        	end

        	return buttonAPI
        end

        return Button

    end

    -- Module: components/label
    EmbeddedModules["components/label"] = function()
        --[[
        	Label Component
        	EzUI Library - Modular Component

        	Creates a text label with optional dynamic function support
        ]]
        local Label = {}

        local Colors

        function Label:Init(_colors)
            Colors = _colors
        end

        function Label:Create(config)
        	local text = config.Text or ""
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local textSize = config.Size or config.TextSize -- Support both Size and TextSize
        	local textColor = config.Color or config.TextColor -- Support both Color and TextColor

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	local label = Instance.new("TextLabel")
        	if isForAccordion then
        		-- Calculate height based on text size with some padding
        		local calculatedTextSize = textSize or 14
        		local labelHeight = math.max(calculatedTextSize + 8, 20) -- Minimum 20px height
        		label.Size = UDim2.new(1, 0, 0, labelHeight)
        		-- Don't set Position for accordion labels - let UIListLayout handle it
        		label.TextSize = calculatedTextSize
        		label.ZIndex = 5
        		-- No debug background needed
        	else
        		label.Size = UDim2.new(1, -20, 0, 30)
        		label.Position = UDim2.new(0, 10, 0, currentY)
        		label.TextSize = textSize or 16
        		label.ZIndex = 3
        		label:SetAttribute("ComponentStartY", currentY)
        	end
        	label.BackgroundTransparency = 1
        	local labelText = type(text) == "function" and text() or text
        	label.Text = tostring(labelText or "")
        	label.TextColor3 = textColor or Colors.Text.Primary

        	-- Debug: Ensure text is visible by using a contrasting color for accordion labels
        	if isForAccordion and not textColor then
        		label.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text for accordion labels
        	end
        	label.TextXAlignment = Enum.TextXAlignment.Left
        	label.Font = Enum.Font.SourceSans
        	label.Visible = true -- Ensure label is visible
        	label.Parent = parentContainer

        	-- Store the text source (function or string)
        	local textSource = text
        	local updateConnection = nil

        	-- Create Label API
        	local labelAPI = {
        		Label = label
        	}

        	-- Function to update text from source
        	local function updateText()
        		if type(textSource) == "function" then
        			local success, result = pcall(textSource)
        			if success then
        				label.Text = tostring(result)
        			else
        				label.Text = "[Error]"
        			end
        		else
        			label.Text = tostring(textSource or "")
        		end
        	end

        	function labelAPI:SetText(newText)
        		textSource = newText
        		updateText()
        	end

        	function labelAPI:GetText()
        		return label.Text
        	end

        	function labelAPI:SetTextColor(color)
        		label.TextColor3 = color
        	end

        	function labelAPI:SetTextSize(size)
        		label.TextSize = size
        		-- Update label height if in accordion
        		if isForAccordion then
        			local labelHeight = math.max(size + 8, 20)
        			label.Size = UDim2.new(1, 0, 0, labelHeight)
        		end
        	end

        	function labelAPI:GetHeight()
        		return label.AbsoluteSize.Y
        	end

        	-- Start auto-update if text is a function
        	function labelAPI:StartAutoUpdate(interval)
        		interval = interval or 1

        		if updateConnection then
        			updateConnection:Disconnect()
        		end

        		if type(textSource) == "function" then
        			local RunService = game:GetService("RunService")
        			local lastUpdate = 0

        			updateConnection = RunService.Heartbeat:Connect(function()
        				local currentTime = tick()
        				if currentTime - lastUpdate >= interval then
        					updateText()
        					lastUpdate = currentTime
        				end
        			end)
        		end
        	end

        	function labelAPI:StopAutoUpdate()
        		if updateConnection then
        			updateConnection:Disconnect()
        			updateConnection = nil
        		end
        	end

        	function labelAPI:Update()
        		updateText()
        	end

        	-- Cleanup when label is destroyed
        	label.AncestryChanged:Connect(function()
        		if not label.Parent then
        			labelAPI:StopAutoUpdate()
        		end
        	end)

        	-- If text is a function, start auto-update by default
        	if type(textSource) == "function" then
        		labelAPI:StartAutoUpdate(1)
        	end

        	return labelAPI
        end

        return Label

    end

    -- Load module helper function
    local function loadModule(url)
        -- Try embedded module first
        if EmbeddedModules[url] then
            return EmbeddedModules[url]()
        end

        -- Fallback to original require
        return require(url)
    end

    -- Main Script
    --[[
    	EzUI - Easy Roblox UI Library
    	Main Entry Point

    	A modern, modular UI library for Roblox with:
    	- Centralized color palette system
    	- Configuration management with auto-save/load
    	- 10+ UI components
    	- Tab system with icons
    	- Window management with drag & resize

    	Usage:
    		local EzUI = require(game.ReplicatedStorage.main)

    		local window = EzUI.({
    			Name = "My UI",
    			Size = {Width = 500, Height = 400}
    		})

    		local tab = window:AddTab("Home")
    		tab:AddButton("Click Me", function()
    		end)
    ]]

    local EzUI = {}

    -- Import utility modules
    local ColorsModule = loadModule("utils/colors")
    local ConfigModule = loadModule("utils/config")

    -- Debug: Verify Colors loaded
    if ColorsModule then
    	if ColorsModule.Background then
    	else
    	end
    else
    end

    -- Import components
    local Accordion = loadModule("components/accordion")
    local Button = loadModule("components/button")
    local Label = loadModule("components/label")
    local NumberBox = loadModule("components/numberbox")
    local Notification = loadModule("components/notification")
    local SelectBox = loadModule("components/selectbox")
    local Separator = loadModule("components/separator")
    local Tab = loadModule("components/tab")
    local TextBox = loadModule("components/textbox")
    local Toggle = loadModule("components/toggle")
    local Window = loadModule("components/window")

    -- Custom Configuration System
    function EzUI:NewConfig(config)
    	return ConfigModule:NewConfig(config)
    end

    -- Initialize Components
    Accordion:Init(ColorsModule, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    Button:Init(ColorsModule)
    Label:Init(ColorsModule)
    NumberBox:Init(ColorsModule)
    SelectBox:Init(ColorsModule)
    Separator:Init(ColorsModule)
    Tab:Init(ColorsModule, Accordion, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    TextBox:Init(ColorsModule)
    Toggle:Init(ColorsModule)
    Window:Init(ColorsModule, Accordion, Button, Label, NumberBox, Notification, SelectBox, Separator, Tab, TextBox, Toggle)

    -- Main Window Creation Function
    function EzUI:CreateNew(config)
    	if not config or type(config) ~= "table" then
    		config = {}
    	end


    	-- Pass all required modules and config to Window component
    	local windowSetup = {
    		Title = config.Title or config.Name or "EzUI Window",
    		Width = config.Width or (config.Size and config.Size.Width) or 600,
    		Height = config.Height or (config.Size and config.Size.Height) or 400,
    		Opacity = config.Opacity or 0.9,
    		AutoShow = config.AutoShow or true,
    		AutoAdapt = config.AutoAdapt or true,
    		Draggable = config.Draggable,
    		BackgroundColor = config.BackgroundColor,
    		CornerRadius = config.CornerRadius,
    	}

    	-- Create config system
    	local configSystem = ConfigModule:NewConfig({
    		FolderName = config.FolderName or "EzUI",
    		FileName = config.FileName or "Settings",
    	})

    	configSystem:Load()

    	local allKeys = configSystem:GetAllKeys()

    	-- Store config in EzUI for global access
    	windowSetup.Settings = configSystem

    	return Window:Create(windowSetup)
    end

    -- Expose version info
    EzUI.Version = "2.0.0"
    EzUI.Author = "EzUI Library"

    return EzUI
end

-- Module: ../module/core.lua
EmbeddedModules["../module/core.lua"] = function()
    local m = {}

    -- Services
    m.Players = game:GetService("Players")
    m.ReplicatedStorage = game:GetService("ReplicatedStorage")
    m.TeleportService = game:GetService("TeleportService")
    m.UserInputService = game:GetService("UserInputService")
    m.GuiService = game:GetService("GuiService")
    m.Workspace = game:GetService("Workspace")
    m.VirtualUser = game:GetService("VirtualUser")
    m.MarketplaceService = game:GetService("MarketplaceService")
    m.PlaceId = game.PlaceId
    m.JobId = game.JobId

    -- Player reference
    m.LocalPlayer = m.Players.LocalPlayer

    -- References
    m.GameEvents = m.ReplicatedStorage.GameEvents

    -- Dynamic getters
    function m:GetCharacter()
        return self.LocalPlayer.Character
    end

    function m:GetHumanoid()
        local char = self:GetCharacter()
        return char and char:FindFirstChildOfClass("Humanoid") or nil
    end

    function m:GetHumanoidRootPart()
        local char = self:GetCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    function m:GetBackpack()
        return self.LocalPlayer:FindFirstChild("Backpack")
    end

    function m:GetPlayerGui()
        return self.LocalPlayer:FindFirstChild("PlayerGui")
    end

    function m:Rejoin()
        if self.PlaceId and self.JobId then
            self.TeleportService:TeleportToPlaceInstance(self.PlaceId, self.JobId, self.LocalPlayer)
        else
            warn("Core:Rejoin - PlaceId or JobId is nil, cannot rejoin.")
        end
    end

    function m:HopServer()
        if self.PlaceId then
            self.TeleportService:Teleport(self.PlaceId, self.LocalPlayer)
        else
            warn("Core:HopServer - PlaceId is nil, cannot hop server.")
        end
    end

    -- Table to track active loops
    local activeLoops = {}

    function m:MakeLoop(_isEnableFunc, _func)
        local loop = coroutine.create(function()
            local lastCheck = 0
            local checkInterval = 5 -- Check config every 5 seconds instead of every 0.1 seconds

            while true do
                local currentTime = tick()
                local isEnabled = false

                -- Only check config periodically to reduce overhead
                if currentTime - lastCheck >= checkInterval then
                    -- Handle both function and direct value
                    if type(_isEnableFunc) == "function" then
                        isEnabled = _isEnableFunc()
                    else
                        isEnabled = _isEnableFunc
                    end
                    lastCheck = currentTime
                end

                if not isEnabled then
                    task.wait(5) -- Longer wait when disabled
                    continue
                end

                _func()
                task.wait(3) -- Longer wait between executions (was 0.1, now 3 seconds)
            end
        end)

        table.insert(activeLoops, loop)
        coroutine.resume(loop)
        return loop
    end

    function m:StopAllLoops()
        for _, loop in ipairs(activeLoops) do
            if loop and coroutine.status(loop) ~= "dead" then
                coroutine.close(loop)
            end
        end
        table.clear(activeLoops)
    end
    return m
end

-- Module: quest/ui.lua
EmbeddedModules["quest/ui.lua"] = function()
    local m = {}
    local Window
    local Core
    local Ascension


    local AscensionItem = {
        Name = "N/A",
        Amount = 0,
        Mutations = "N/A",
        IsEligibleToSubmit = false,
        NextRebirthSubmitTime = 0
    }

    function m:Init(_window, _core, _ascension)
        Window = _window
        Core = _core
        Ascension = _ascension

        AscensionItem = Ascension:GetQuestDetail()
    end

    function m:CreateQuestTab()
        local tab = Window:AddTab({
            Name = "Quests",
            Icon = "📜",
        })

        -- Ascension
        self:AscensionSection(tab)
    end

    local function getTimeRemaining()
        if not AscensionItem.NextRebirthSubmitTime then
            return "N/A"
        end

        if AscensionItem.IsEligibleToSubmit then
            return "Ready"
        end

        local remainingSeconds = AscensionItem.NextRebirthSubmitTime - tick()
        if remainingSeconds <= 0 then
            return "Ready"
        end

        local hours = math.floor(remainingSeconds / 3600)
        local minutes = math.floor((remainingSeconds % 3600) / 60)
        local seconds = remainingSeconds % 60
        local parseTime = string.format("%02d:%02d:%02d", hours, minutes, seconds)

        return parseTime
    end

    function m:AscensionSection(tab)
        local accordion = tab:AddAccordion({
            Name = "Ascension",
            Icon = "🔃",
            Expanded = false,
            Callback = function(isExpanded)
                if not isExpanded then
                    return
                end

                local ascensionItem = Ascension:GetQuestDetail()

                if not ascensionItem then
                    return
                end

                if ascensionItem.Name ~= AscensionItem.Name or
                   ascensionItem.Mutations ~= AscensionItem.Mutations then
                    AscensionItem = ascensionItem
                end
            end,
        })

        accordion:AddLabel(function()
            return "Current Quest: ".. AscensionItem.Amount .. " " .. AscensionItem.Name .. " (" .. (AscensionItem.Mutations ~= "" and AscensionItem.Mutations or "No Mutation") .. ")"
        end)
        accordion:AddLabel(function()
            return "Next Rebirth Submit Time: " .. getTimeRemaining()
        end)

        accordion:AddSelectBox({
            Name = "Position planting seeds",
            Flag = "PlantingAscensionPosition",
            Options = {"Random", "Front Right", "Front Left", "Back Right", "Back Left"},
            Default = "Random",
            MultiSelect = false,
            Placeholder = "Select position...",
        })

        accordion:AddToggle({
            Name = "Auto Ascend",
            Default = false,
            Flag = "AutoAscend",
            Tooltip = "Automatically ascend when the option is available.",
        })
    end

    return m
end

-- Module: auto/crafting.lua
EmbeddedModules["auto/crafting.lua"] = function()
    local m = {}

    local Window
    local Core

    local MachineTypes = {}
    local CraftingRecipeRegistry
    local Recipes
    local CraftingUtil
    local Plant

    m.StationRepository = {
        GearEventWorkbench = workspace.CraftingTables.EventCraftingWorkBench,
        SeedEventCraftingWorkBench = workspace.CraftingTables.SeedEventCraftingWorkBench,
    }

    function m:Init(window, core, plant)
        Window = window
        Core = core
        Plant = plant

        CraftingRecipeRegistry = require(Core.ReplicatedStorage.Data.CraftingData.CraftingRecipeRegistry)
        Recipes = CraftingRecipeRegistry.ItemRecipes
        CraftingUtil = require(Core.ReplicatedStorage.Modules.CraftingService.CraftingGlobalObjectService)

        self:InitCraftingRecipes()

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoCraftingGear")
            end, 
            function()
                self:CraftingController( 
                    self.StationRepository.GearEventWorkbench,
                    Window:GetConfigValue("CraftingGearItem")
                )
            end
        )

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoCraftingSeeds")
            end, 
            function()
                self:CraftingController( 
                    self.StationRepository.SeedEventCraftingWorkBench,
                    Window:GetConfigValue("CraftingSeedItem")
                )
            end
        )
    end

    function m:GetCraftingObjectType(craftingStation)
        return craftingStation:GetAttribute("CraftingObjectType")
    end 

    function m:InitCraftingRecipes()
        if #MachineTypes > 0 then
            return MachineTypes
        end

        MachineTypes = CraftingRecipeRegistry.RecipiesSortedByMachineType or {}

        return MachineTypes
    end

    function m:GetMachineTypes()
        local machineTypes =  {}

        for machineType, _ in pairs(MachineTypes) do
            table.insert(machineTypes, machineType)
        end

        return machineTypes
    end

    function m:GetAllCraftingItems(craftingStation)
        local machineType = self:GetCraftingObjectType(craftingStation)
        local craftingItems = {}

        for item, _ in pairs(MachineTypes[machineType] or {}) do
            table.insert(craftingItems, item)
        end

        -- Sort the crafting items alphabetically
        table.sort(craftingItems)

        return craftingItems
    end

    function m:GetCraftingData(craftingStation, craftingItem)
        local machineType = self:GetCraftingObjectType(craftingStation)
        local data = {}

        for items, detail in pairs(MachineTypes[machineType] or {}) do
            if items == craftingItem then
                table.insert(data, detail)
                break
            end
        end

        return data
    end

    function m:GetCraftingRecipes(craftingStation, craftingItem)
        local craftingData = self:GetCraftingData(craftingStation, craftingItem)
        local craftingInputs = {}
        local recipes = {}

        if #craftingData == 0 then
            return recipes
        end

        for _, detail in pairs(craftingData) do
            if type(detail) == "table" and detail.Inputs then
                for _, input in pairs(detail.Inputs) do
                    table.insert(craftingInputs, input)
                end
                continue
            end
        end

        for i, input in pairs(craftingInputs) do
            local dataItems
            table.insert(recipes, input)
        end

        return recipes
    end

    function m:GetCraftingStationStatus(craftingStation)
        local data = CraftingUtil:GetIndividualCraftingMachineData(craftingStation, self:GetCraftingObjectType(craftingStation))
        if not data or not data.RecipeId then
            return "Idle"
        end

        local unsubmittedItems = self:GetUnsubmittedItems(craftingStation)
        if #unsubmittedItems > 0 then
            return "Waiting for Item"
        end

        local craftingItem = data.CraftingItems and data.CraftingItems[1]
        if craftingItem then
            if craftingItem.IsDone then
                return "Ready to Claim"
            else
                return "On Progress"
            end
        end

        return "Ready to Start"
    end

    function m:SetRecipe(craftingStation, craftingItem)
        if not craftingStation or not craftingItem then
            return
        end

        Core.GameEvents.CraftingGlobalObjectService:FireServer(
            "SetRecipe",
            craftingStation,
            self:GetCraftingObjectType(craftingStation),
            craftingItem
        )
    end

    function m:SubmitCraftingRequest(craftingStation)
        local craftingHandler = require(Core.ReplicatedStorage.Modules.CraftingStationHandler)

        local success, error = pcall(function() 
            craftingHandler:SubmitAllRequiredItems(craftingStation) 
        end)

        if not success then
            warn("Error submitting crafting request:", error)
            return
        end

        local unsubmittedItems = self:GetUnsubmittedItems(craftingStation)

        if #unsubmittedItems == 0 then
            return
        end

        local needFruits = {}
        for _, item in pairs(unsubmittedItems) do
            if item.ItemType == "Holdable" then
                table.insert(needFruits, item.ItemData.ItemName)
            end
        end

        if #needFruits == 0 then
            return
        end

        for _, fruit in pairs(needFruits) do
            local plants = Plant:FindPlants(fruit) or {}

            if #plants == 0 then
                continue
            end

            for _, plant in pairs(plants) do
                local plantDetail = Plant:GetPlantDetail(plant)
                local successHarvest
                if not plantDetail or #plantDetail.fruits == 0 then
                    continue
                end

                for _, harvestingFruit in pairs(plantDetail.fruits) do
                    if not harvestingFruit.isEligibleToHarvest then
                        continue
                    end

                    successHarvest = pcall(function()
                        Plant:HarvestFruit(harvestingFruit.model)
                    end)
                end

                if successHarvest then
                    break
                end
            end
        end
    end

    function m:StartCrafting(craftingStation)
        local unsubmittedItems = self:GetUnsubmittedItems(craftingStation)

        if #unsubmittedItems > 0 then
            return
        end

        local OpenRecipeEvent = Core.GameEvents.OpenRecipeBindableEvent

        local success, error = pcall(function()
            Core.GameEvents.CraftingGlobalObjectService:FireServer(
                "Craft",
                craftingStation,
                self:GetCraftingObjectType(craftingStation)
            )
        end)

        if not success then
            warn("Error starting crafting:", error)
            return
        end
    end

    function m:CraftingController(craftingStation, craftingItem)
        if not craftingStation or not craftingItem then
            return
        end

        if self:GetCraftingStationStatus(craftingStation) == "Idle" then
            self:SetRecipe(craftingStation, craftingItem)
            task.wait(0.5) -- Wait for 0.5 seconds to allow the station to update its status
        end

        while self:GetCraftingStationStatus(craftingStation) == "Waiting for Item" do
            self:SubmitCraftingRequest(craftingStation)

            wait(5) -- Wait for 5 seconds before checking again
        end

        if  self:GetCraftingStationStatus(craftingStation) == "Ready to Start" then
            self:StartCrafting(craftingStation)
            task.wait(0.5) -- Wait for 0.5 seconds to allow the crafting process to start
        end

        while self:GetCraftingStationStatus(craftingStation) == "On Progress" do
            wait(5) -- Wait for 5 seconds before checking again
        end

        if self:GetCraftingStationStatus(craftingStation) == "Ready to Claim" then
            local success, error = pcall(function()
                Core.GameEvents.CraftingGlobalObjectService:FireServer(
                    "Claim",
                    craftingStation,
                    self:GetCraftingObjectType(craftingStation),
                    1
                )
            end)

            if not success then
                warn("Error claiming crafted item:", error)
                return
            end

            task.wait(0.5) -- Wait for 0.5 seconds to allow the
        end
    end

    function m:GetSubmittedItems(craftingStation)
    	local machineData = CraftingUtil:GetIndividualCraftingMachineData(craftingStation, self:GetCraftingObjectType(craftingStation))
        local submittedItems = {}

        if not (machineData and machineData.RecipeId) then
    		return submittedItems
    	end

        if not Recipes[machineData.RecipeId] then
    		return submittedItems
    	end

        for item, _ in machineData.InputItems do
    		submittedItems[tostring(item)] = true
    	end

        return submittedItems
    end

    function m:GetUnsubmittedItems(craftingStation)
        local submitted = self:GetSubmittedItems(craftingStation)
        local machineData = CraftingUtil:GetIndividualCraftingMachineData(craftingStation, self:GetCraftingObjectType(craftingStation))

        local recipe = machineData and machineData.RecipeId and Recipes[machineData.RecipeId]
        local result = {}

        if recipe then
            for id, input in pairs(recipe.Inputs) do
                if not submitted[tostring(id)] then
                    table.insert(result, input)
                end
            end
        end

        return result
    end

    return m
end

-- Module: inventory/ui.lua
EmbeddedModules["inventory/ui.lua"] = function()
    local m = {}

    local Window
    local Inventory
    local Pet

    function m:Init(_window, _inventory, _pet)
        Window = _window
        Inventory = _inventory
        Pet = _pet
    end

    function m:CreateTab()
        local tab = Window:AddTab({
            Name = "Inventory",
            Icon = "🎒"
        })

        self:AddPetSection(tab)
    end

    function m:AddPetSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Pets",
            Icon = "🐶",
            Expanded = false,
        })

        accordion:AddSelectBox({
            Name = "Select pet name for auto favorite",
            Options = {"Loading..."},
            Placeholder = "Select a pet",
            MultiSelect = true,
            Flag = "AutoFavoritePetName",
           OnInit = function(api, optionsData)
                local specialPets = Pet:GetPetRegistry()
                optionsData.updateOptions(specialPets)
            end
        })

        accordion:AddNumberBox({
            Name = "Or If Weight Is Higher Than Or Equal To",
            Placeholder = "Enter weight...",
            Default = 0.0,
            Min = 0.0,
            Max = 20.0,
            Increment = 1.0,
            Decimals = 2,
            Flag = "AutoFavoritePetWeight",
        })

        accordion:AddNumberBox({
            Name = "Or If Age Is Higher Than Or Equal To",
            Placeholder = "Enter age...",
            Default = 0,
            Min = 0,
            Max = 100,
            Increment = 1,
            Flag = "AutoFavoritePetAge",
        })

        accordion:AddToggle({
            Name = "Auto Favorite Pets",
            Flag = "AutoFavoritePets",
            Default = false,
            Callback = function(value)
                if value then
                    Inventory:FavoriteAllPets()
                end
            end
        })
    end

    return m
end

-- Module: event/ghoul/shop.lua
EmbeddedModules["event/ghoul/shop.lua"] = function()
    local m = {}

    local Window
    local Core
    local Shop
    local ShopUI = "EventShop_UI"

    local ShopData
    local DataService

    local ShopStockConnection

    m.Merchant = {
        "Spooky Seeds",
        "Creepy Critters",
        "Devilish Decor",
    }

    function m:Init(_window, _core, _shop)
        Window = _window
        Core = _core
        Shop = _shop

        ShopData = require(Core.ReplicatedStorage.Data.EventShopData)
        DataService = require(Core.ReplicatedStorage.Modules.DataService)

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoBuySpookyShop")
            end, 
            function()
                self:StartAutoBuySpookySeeds()
            end
        )

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoBuyCreepyShop")
            end, 
            function()
                self:StartAutoBuyCreepyCritters()
            end
        )

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoBuyDevilishShop")
            end, 
            function()
                self:StartAutoBuyDevilishDecor()
            end
        )
    end

    function m:GetItemRepository(merchant)
        return ShopData[merchant] or {}
    end

    function m:GetDetailItem(merchant, itemName)
        local items = self:GetItemRepository(merchant)
        return items[itemName] or nil
    end

    function m:GetStock(shopName, itemName)
        local shopData = DataService:GetData()
        local stock = 0
        if not shopData then
            return stock
        end

        stock = shopData.EventShopStock[shopName].Stocks[itemName] or 0

        if type(stock) ~= "number" then
            return stock.Stock or 0
        end

        return stock
    end

    function m:GetAvailableItems(merchant)
        local items = self:GetItemRepository(merchant)
        local availableItems = {}

        for itemName, _ in pairs(items) do
            local stock = self:GetStock(merchant, itemName) or 0 or 0
            if stock > 0 then
                table.insert(availableItems, itemName)
            end
        end

        return availableItems
    end

    function m:StartAutoBuySpookySeeds()
        if not Window:GetConfigValue("AutoBuySpookyShop") then
            return
        end

        local merchant = "Spooky Seeds"
        local itemNames = Window:GetConfigValue("SpookyShopItem")
        if not itemNames or #itemNames == 0 then
            warn("No items selected for auto-buy")
            return
        end

        for _, itemName in ipairs(itemNames) do
            local stock = self:GetStock(merchant, itemName) or 0

            if stock <= 0 then
                continue
            end

            for i = 1, stock do
                Core.GameEvents.BuyEventShopStock:FireServer(itemName, merchant)
            end
        end
    end

    function m:StartAutoBuyCreepyCritters()
        if not Window:GetConfigValue("AutoBuyCreepyShop") then
            return
        end

        local merchant = "Creepy Critters"
        local itemNames = Window:GetConfigValue("CreepyShopItem")
        if not itemNames or #itemNames == 0 then
            warn("No items selected for auto-buy")
            return
        end

        for _, itemName in ipairs(itemNames) do
            local stock = self:GetStock(merchant, itemName) or 0

            if stock <= 0 then
                continue
            end

            for i = 1, stock do
                Core.GameEvents.BuyEventShopStock:FireServer(itemName, merchant)
            end
        end
    end

    function m:StartAutoBuyDevilishDecor()
        if not Window:GetConfigValue("AutoBuyDevilishShop") then
            return
        end

        local merchant = "Devilish Decor"
        local itemNames = Window:GetConfigValue("DevilishShopItem")
        if not itemNames or #itemNames == 0 then
            warn("No items selected for auto-buy")
            return
        end

        for _, itemName in ipairs(itemNames) do
            local stock = self:GetStock(merchant, itemName) or 0

            if stock <= 0 then
                continue
            end

            for i = 1, stock do
                Core.GameEvents.BuyEventShopStock:FireServer(itemName, merchant)
            end
        end
    end

    return m
end

-- Module: ../module/discord.lua
EmbeddedModules["../module/discord.lua"] = function()
    local m = {}
    local HttpService = game:GetService("HttpService")

    function m:SendMessage(webhookUrl, data)
        -- Mencari fungsi request yang tersedia dari berbagai executor
        local requestFunction = request or
                               (syn and syn.request) or
                               (http and http.request) or
                               (fluxus and fluxus.request) or
                               http_request

        -- Jika tidak ada fungsi request yang tersedia, keluar dari fungsi
        if not requestFunction then
            return
        end

        -- Mengubah data menjadi format JSON
        local jsonData = HttpService:JSONEncode(data)

        -- Menyiapkan headers untuk request
        local headers = {
            ['Content-Type'] = "application/json"
        }

        -- Mengirim POST request ke webhook
        local success, err = pcall(function()
            task.spawn(requestFunction, {
                Url = webhookUrl,
                Body = jsonData,
                Method = 'POST',
                Headers = headers
            })
        end)

        if success then
            print("Discord webhook sent successfully.")
        else
            warn("Failed to send Discord webhook:", err)
        end
    end

    return m

end

-- Module: server/ui.lua
EmbeddedModules["server/ui.lua"] = function()
    local m = {}
    local Window
    local Core
    local Player
    local Garden

    function m:Init(_window, _core, _player, _garden)
        Window = _window
        Core = _core
        Player = _player
        Garden = _garden
    end

    function m:CreateServerTab()
        local tab = Window:AddTab({
            Name = "Server",
            Icon = "🌐",
        })

        tab:AddButton({Text = "Rejoin Server 🔄", Callback = function()
            Core:Rejoin()
        end})

        tab:AddButton({Text = "Hop Server 🚀", Callback = function()
            Core:HopServer()
        end})
    end

    return m
end

-- Module: shop/seed.lua
EmbeddedModules["shop/seed.lua"] = function()
    local m = {}

    local Window
    local Core
    local Shop

    local Connections
    local ShopUI = "Seed_Shop"
    local ShopItem = "Carrot"

    function m:Init(_window, _core, _shop)
        Window = _window
        Core = _core
        Shop = _shop

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuySeeds")
        end, function()
            self:BuyAllSeeds()
        end)
    end

    function m:BuySeed(seedName)
        if not seedName or seedName == "" then
            warn("Invalid seed name")
            return
        end

        Core.GameEvents.BuySeedStock:FireServer("Tier 1", seedName)
    end

    function m:BuyAllSeeds()
        local items = Shop:GetAvailableItems(ShopUI)

        for seedName, stock in pairs(items) do
            if stock and stock < 1 then
                continue
            end

            for i = 1, stock do
                self:BuySeed(seedName)
                task.wait(0.1)
            end
        end
    end

    function m:StartSeedAutomation()
        if not Window:GetConfigValue("AutoBuySeeds") then
            return
        end

        self:BuyAllSeeds()

        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end

        Connections = {}
        for _, item in pairs(Shop:GetListItems(ShopUI)) do
            local conn = Shop:ConnectToStock(item, function()
                if Window:GetConfigValue("AutoBuySeeds") then
                    return
                end

                self:BuyAllSeeds()
            end)
            table.insert(Connections, conn)
        end
    end

    function m:StopSeedAutomation()
        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end
    end

    return m
end

-- Module: auto/ui.lua
EmbeddedModules["auto/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Crafting


    function m:Init(_window, _core, _crafting)
        Window = _window
        Core = _core
        Crafting = _crafting

        local tab = Window:AddTab({
            Name = "AutoMation",
            Icon = "🔧",
        })

        self:CraftingGearSection(tab)
        self:CraftingSeedSection(tab)
    end

    function m:CraftingGearSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Crafting Gear",
            Icon = "⚙️",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Crafting Item ⚙️",
            Options = {"loading ..."},
            Placeholder = "Select Crafting Item",
            Flag = "CraftingGearItem",
            OnInit =  function(api, optionsData)
                local craftingItems = Crafting:GetAllCraftingItems(Crafting.StationRepository.GearEventWorkbench)

                optionsData.updateOptions(craftingItems)
            end
        })

        accordion:AddToggle({
            Name = "Auto Crafting Gear ⚙️",
            Default = false,
            Flag = "AutoCraftingGear",
        })
    end

    function m:CraftingSeedSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Crafting Seeds",
            Icon = "🌱",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Crafting Item 🌱",
            Options = {"loading ..."},
            Placeholder = "Select Crafting Item",
            Flag = "CraftingSeedItem",
            OnInit =  function(api, optionsData)
                local craftingItems = Crafting:GetAllCraftingItems(Crafting.StationRepository.SeedEventCraftingWorkBench)

                optionsData.updateOptions(craftingItems)
            end
        })

        accordion:AddToggle({
            Name = "Auto Crafting Seeds 🌱",
            Default = false,
            Flag = "AutoCraftingSeeds",
        })
    end

    return m
end

-- Module: farm/plant.lua
EmbeddedModules["farm/plant.lua"] = function()
    local m = {}
    local Window
    local Core
    local Player
    local Garden
    local PlantsPhysical

    function m:Init(_window, _core, _player, _garden)
        Window = _window
        Core = _core
        Player = _player
        Garden = _garden

        local myGarden = Garden:GetMyFarm()
        if not myGarden then
            warn("Failed to find player's garden")
            return
        end

        local important = myGarden:FindFirstChild("Important")
        PlantsPhysical = important:FindFirstChild("Plants_Physical")  

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoPlantSeeds")
        end, function()
            self:StartAutoPlanting()
        end)

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoWateringPlants")
        end, function()
            self:AutoWateringPlants()
        end)

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoHarvestPlants")
        end, function()
            self:StartAutoHarvesting()
        end)
    end

    function m:GetPlantRegistry()
        local success, seedRegistry = pcall(function()
            return require(Core.ReplicatedStorage.Data.SeedData)
        end)

        if not success then
            warn("Failed to get seed registry:", seedRegistry)
            return {}
        end

        if not seedRegistry then
            warn("SeedData is nil or not found")
            return {}
        end

       -- Convert SeedData to UI format {text = ..., value = ...}
        local formattedSeeds = {}
        for seedName, seedData in pairs(seedRegistry) do
            table.insert(formattedSeeds, {
                seed = seedData.SeedName or seedName,
                plant = seedName,
                rarity = seedData.SeedRarity or "Unknown",
            })
        end

        -- Sort seeds alphabetically (ascending order) - Safe for all executors
        if #formattedSeeds > 0 then
            table.sort(formattedSeeds, function(a, b)
                if not a or not b or not a.plant or not b.plant then
                    return false
                end
                return string.lower(tostring(a.plant)) < string.lower(tostring(b.plant))
            end)
        end

        return formattedSeeds
    end

    function m:PlantSeed(_seedName, _numToPlant, _plantingPosition)
        if not _seedName or type(_seedName) ~= "string" then
            warn("FarmUtils:PlantSeed - Invalid seed name")
            return false
        end

        if #PlantsPhysical:GetChildren() >= 800 then
            return false
        end

        local tool
        local toolQuantity = 0

        for _, t in next, Player:GetAllTools() do
            local toolType = t:GetAttribute("b")
            local toolSeed = t:GetAttribute("Seed")
            if toolType == "n" and toolSeed == _seedName then
                tool = t
                toolQuantity = t:GetAttribute("Quantity") or 0
                break
            end
        end

        if toolQuantity < _numToPlant then
            _numToPlant = toolQuantity
        end

        if not tool then
            print("No seed tool found for seed:", _seedName)

            return false
        end

        local position = Garden:GetFarmRandomPosition()
        if _plantingPosition == "Front Right" then
            position = Garden:GetFarmFrontRightPosition()
        elseif _plantingPosition == "Front Left" then
            position = Garden:GetFarmFrontLeftPosition()
        elseif _plantingPosition == "Back Right" then
            position = Garden:GetFarmBackRightPosition()
        elseif _plantingPosition == "Back Left" then
            position = Garden:GetFarmBackLeftPosition()
        end
        if not position then
            warn("Failed to get farm position for planting")
            return false
        end

        local plantTask = function(_numToPlant, _seedName, _position)
            for i = 1, _numToPlant do
                if #PlantsPhysical:GetChildren() >= 800 then
                    break
                end            
                Core.GameEvents.Plant_RE:FireServer(_position, _seedName)
                -- Small delay between planting actions
                task.wait(0.15)
            end
        end

        Player:AddToQueue(
            tool,       -- tool
            3,          -- priority (medium)
            function()
                plantTask(_numToPlant, _seedName, position)
            end
        )
    end

    function m:FindPlants(plantName)
        if not plantName or type(plantName) ~= "string" then
            warn("Invalid plant name")
            return nil
        end

        if not PlantsPhysical then
            warn("PlantsPhysical not found")
            return nil
        end

        local foundPlants = {}
        for _, plant in pairs(PlantsPhysical:GetChildren()) do
            if plant.Name == plantName then
                table.insert(foundPlants, plant)
            end
        end

        return #foundPlants > 0 and foundPlants or nil
    end

    function m:StartAutoPlanting()
        local seedsToPlant = Window:GetConfigValue("SeedsToPlant") or {}
        local seedToPlantCount = Window:GetConfigValue("SeedsToPlantCount") or 1
        local plantingPosition = Window:GetConfigValue("PlantingPosition") or "Random"

        -- Cache plant count once at the beginning
        if #PlantsPhysical:GetChildren() >= 800 then
            task.wait(30) -- Much longer wait when farm is full
            return
        end

        local plantsNeeded = false

        for _, seedName in pairs(seedsToPlant) do
            if #PlantsPhysical:GetChildren() >= 800 then
                break
            end
            local existingPlants = self:FindPlants(seedName) or {}
            local numExisting = #existingPlants
            local numToPlant = math.max(0, seedToPlantCount - numExisting)

            if numToPlant > 0 then
                self:PlantSeed(seedName, numToPlant, plantingPosition)
                plantsNeeded = true
            end
        end

        if not plantsNeeded then
            task.wait(60) -- Much longer wait when nothing to do
        else
            task.wait(15) -- Moderate wait when work was done
        end
    end

    function m:AutoWateringPlants()
        local wateringCan
        local wateringDelay = Window:GetConfigValue("WateringDelay") or 2
        local wateringEach = Window:GetConfigValue("WateringEach") or 5
        local wateringPosition = Window:GetConfigValue("WateringPosition") or "Front Right"
        local position = Garden:GetFarmRandomPosition()

        for _, Tool in next, Player:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            if toolType == "o" then
                wateringCan = Tool
                break
            end
        end

        if not wateringCan then
            warn("No watering can found in inventory")
            return
        end

        local growingPlants = self:GetAllGrowingPlants()
        if #growingPlants < 1 then
            task.wait(10) -- Wait before checking again
            return
        end

        local tasks = Player:GetTaskByTool(wateringCan)
        if tasks and #tasks > 0 then
            task.wait(10)
            return
        end

        if wateringPosition == "Growing Plants" then
            position = growingPlants[1]:GetPivot().Position
        elseif wateringPosition == "Front Right" then
            position = Garden:GetFarmFrontRightPosition()
        elseif wateringPosition == "Front Left" then
            position = Garden:GetFarmFrontLeftPosition()
        elseif wateringPosition == "Back Right" then
            position = Garden:GetFarmBackRightPosition()
        elseif wateringPosition == "Back Left" then
            position = Garden:GetFarmBackLeftPosition()
        end

        local wateringTask = function(position, each)
            local watered = 0

            for i = 1, each do
                local success = pcall(function()
                    Core.GameEvents.Water_RE:FireServer(Vector3.new(position.X, 0, position.Z))
                end)

                if success then
                    watered = watered + 1
                end

                task.wait(1.5) -- Slightly longer delay to reduce server load
            end

            task.wait(0.5) -- Longer final wait
        end


        Player:AddToQueue(
            wateringCan,   -- tool
            99,             -- priority (very low)
            function()
                wateringTask(position, wateringEach)
            end
        )
        task.wait(math.max(wateringDelay, 5)) -- Minimum 5 second delay
    end

    function m:EligibleToHarvest(plant)    
        local Prompt = plant:FindFirstChild("ProximityPrompt", true)
        if not Prompt then return false end
        if not Prompt.Enabled then return false end

        return true
    end

    function m:GetAllGrowingPlants()
        if not PlantsPhysical then
            warn("PlantsPhysical not found")
            return {}
        end

        local growingPlants = {}
        for _, plant in pairs(PlantsPhysical:GetChildren()) do
            local prompt = plant:FindFirstChild("ProximityPrompt", true)
            if not prompt then
                table.insert(growingPlants, plant)
            end
        end

        return growingPlants
    end

    function m:IsMaxInventory()
        local character = Core.LocalPlayer
        local backpack = Core:GetBackpack()
        if not character or not backpack then
            warn("FarmUtils:IsMaxFruitInventory - Character or Backpack not found")
            return false
        end

        local bonusBackpack = character:GetAttribute("BonusBackpackSize") or 0
        local maxCapacity = 200 + bonusBackpack
        local currentItems = 0

        for _, item in pairs(backpack:GetChildren()) do
            if item:GetAttribute("b") == "j" then
                currentItems = currentItems + 1
            end
        end

        return currentItems >= maxCapacity
    end

    function m:GetFruitPlant(plan)
        local fruits = {}

        for _, child in pairs(plan.Fruits:GetChildren()) do
            table.insert(fruits, child)
        end

        return fruits
    end

    function m:GetPlantDetail(_plant)
        if not _plant or not _plant:IsA("Model") then
            warn("Invalid plant")
            return nil
        end

        local prompt = _plant:FindFirstChild("ProximityPrompt", true)
        local parentFruit = prompt and prompt.Parent.Parent.Parent
        local fruits = {}

        if not prompt or not parentFruit then
            -- No prompt means not ready to harvest, so no fruits
            fruits = {}
        elseif parentFruit and parentFruit.Name == "Fruits" then
            for _, fruit in pairs(parentFruit:GetChildren()) do
                table.insert(fruits, fruit)
            end
        else
            fruits = { _plant }
        end

        local doneGrowTime = _plant:GetAttribute("DoneGrowTime") or math.huge

        local detail = {
            name = _plant.Name or "Unknown",
            position = _plant:GetPivot().Position or Vector3.new(0,0,0),
            isGrowing = not prompt or false,
            fruits = {},
        }

        for _, fruit in pairs(fruits) do
            local mutations = {}

            for attributeName, attributeValue in pairs(fruit:GetAttributes()) do
                if attributeValue == true then
                    table.insert(mutations, attributeName)
                end
            end

            table.insert(detail.fruits, {
                isEligibleToHarvest = self:EligibleToHarvest(fruit),
                mutations = mutations,
                model = fruit,
            })
        end

        return detail
    end

    function m:HarvestFruit(_fruit)
        if not _fruit or not _fruit:IsA("Model") then
            warn("Invalid plant or fruit")
            return false
        end

        if not self:EligibleToHarvest(_fruit) then
            return false
        end

        if self:IsMaxInventory() then
            return false
        end

        local success, err = pcall(function()
            Core.GameEvents.Crops.Collect:FireServer({_fruit})
        end)

        if not success then
            warn("Failed to harvest item:", _fruit.Name, "Error:", err)
            return false
        end

        return true
    end

    function m:StartAutoHarvesting()
        if Window:GetConfigValue("AutoHarvestPlants") ~= true then
            warn("Auto harvesting is disabled in config")
            return
        end

        if self:IsMaxInventory() then
            task.wait(10) -- Wait before checking again
            return
        end

        local plantsToHarvest = Window:GetConfigValue("PlantsToHarvest") or {}
        if #plantsToHarvest == 0 then
            warn("No plants selected for auto harvesting")
            task.wait(10) -- Wait before checking again
            return
        end

        local harvestedCount = 0

        for _, plantName in pairs(plantsToHarvest) do
            local plants = self:FindPlants(plantName) or {}

            -- Harvest with limits
            for _, plant in pairs(plants) do
                if self:IsMaxInventory() then
                    break
                end

                local plantDetail = self:GetPlantDetail(plant)
                if not plantDetail or plantDetail.isGrowing then
                    continue
                end

                for _, fruitDetail in pairs(plantDetail.fruits) do
                    if self:IsMaxInventory() then
                        break
                    end

                    if not fruitDetail.isEligibleToHarvest then
                        continue
                    end

                    local success = self:HarvestFruit(fruitDetail.model)
                    if success then
                        harvestedCount = harvestedCount + 1
                        task.wait(0.15) -- Small delay between harvests
                    end
                end
            end

            if self:IsMaxInventory() then
                break
            end
        end

        if harvestedCount > 0 then
            task.wait(0.5) -- Moderate wait after work
        else
            task.wait(15) -- Longer wait when nothing to do
        end
    end

    function m:MovePlant()
        local plantToMove = Window:GetConfigValue("PlantToMove")
        if not plantToMove or type(plantToMove) ~= "string" then
            warn("Invalid plant selected for moving")
            return
        end
        local moveDestination = Window:GetConfigValue("MoveDestination")
        if not moveDestination or type(moveDestination) ~= "string" then
            warn("Invalid move destination selected")
            return
        end

        local plants = self:FindPlants(plantToMove) or {}

        if #plants == 0 then
            warn("No plants found to move")
            return
        end

        local position = Garden:GetFarmRandomPosition()
        if moveDestination == "Front Right" then
            position = Garden:GetFarmFrontRightPosition()
        elseif moveDestination == "Front Left" then
            position = Garden:GetFarmFrontLeftPosition()
        elseif moveDestination == "Back Right" then
            position = Garden:GetFarmBackRightPosition()
        elseif moveDestination == "Back Left" then
            position = Garden:GetFarmBackLeftPosition()
        end
        if not position then
            warn("Failed to get farm position for moving")
            return
        end

        local trowel
        for _, Tool in next, Player:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            if toolType == "b" then
                trowel = Tool
                break
            end
        end
        if not trowel then
            warn("No trowel found in inventory")
            return
        end

        local moveTask = function(plants, position)
            for _, plant in pairs(plants) do
                if not plant or not plant:IsA("Model") then
                    continue
                end

                local success = pcall(function()
                    Core.GameEvents.TrowelRemote:InvokeServer(
                        "Pickup",
                        trowel,
                        plant
                    )
                end)

                if success then
                    task.wait(0.5) -- Small delay between moves
                end

                local successPlace = pcall(function()
                    Core.GameEvents.TrowelRemote:InvokeServer(
                        "Place",
                        trowel,
                        plant,
                        CFrame.new(position.X, 0.5, position.Z)
                    )
                end)

                if not successPlace then
                    warn("Failed to place plant:", plant.Name)
                end
            end
        end

        Player:AddToQueue(
            trowel,     -- tool
            10,          -- priority (high)
            function()
                moveTask(plants, position)
            end
        )
    end
    return m
end

-- Module: shop/egg.lua
EmbeddedModules["shop/egg.lua"] = function()
    local m = {}

    local Window
    local Core
    local Shop

    local Connections
    local ShopUI = "PetShop_UI"
    local ShopItem = "Common Egg"

    function m:Init(_window, _core, _shop)
        Window = _window
        Core = _core
        Shop = _shop

        _core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuyEggs")
        end, function()
            self:BuyAllEggs()
        end)
    end

    function m:BuyEgg(eggName)
        if not eggName or eggName == "" then
            warn("Invalid egg name")
            return
        end

        Core.GameEvents.BuyPetEgg:FireServer(eggName)
    end

    function m:BuyAllEggs()
         local items = Shop:GetAvailableItems(ShopUI)

        for eggName, stock in pairs(items) do
            if stock < 1 then
                continue
            end

            for i = 1, stock do
                self:BuyEgg(eggName)
                task.wait(0.1) -- Small delay to avoid spamming
            end
        end
    end

    function m:StartEggAutomation()
        if not Window:GetConfigValue("AutoBuyEggs") then
            return
        end

        self:BuyAllEggs()

        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end

        Connections = {}
        for _, item in pairs(Shop:GetListItems(ShopUI)) do
            local conn = Shop:ConnectToStock(item, function()
                if not Window:GetConfigValue("AutoBuyEggs") then
                    return
                end

                self:BuyAllEggs()
            end)
            table.insert(Connections, conn)
        end
    end

    function m:StopEggAutomation()
        if Connections then
            for _, conn in pairs(Connections) do
                conn:Disconnect()
            end
            Connections = nil
        end
    end

    return m
end

-- Module: ../module/player.lua
EmbeddedModules["../module/player.lua"] = function()
    local m = {}

    -- Load Core module with error handling
    local Core
    local AntiAFKConnection -- Store the connection reference
    local ReconnectConnection

    -- Queue system for tool equipping
    local ToolQueue = {
        Queue = {},
        IsProcessing = false,
        CurrentTask = nil
    }

    function m:Init(_core)
        if not _core then
            error("Player:Init - Core module is required")
        end
        Core = _core

        -- Store the connection so we can disconnect it later
        AntiAFKConnection = Core.LocalPlayer.Idled:Connect(function()
            Core.VirtualUser:CaptureController()
            Core.VirtualUser:ClickButton2(Vector2.new())
            print("Anti-AFK: Clicked to prevent idle kick")
        end)

        ReconnectConnection = Core.GuiService.ErrorMessageChanged:Connect(function()
            local IsSingle = #Core.Players:GetPlayers() <= 1

            --// Join a different server if the player is solo
            if IsSingle then
                Core:HopServer()
                return
            end

            Core:Rejoin()
        end)

        -- Initialize queue system
        ToolQueue.Queue = {}
        ToolQueue.IsProcessing = false
        ToolQueue.CurrentTask = nil
    end

    function m:RemoveAntiAFK()
        -- Disconnect the stored connection
        if AntiAFKConnection then
            AntiAFKConnection:Disconnect()
            AntiAFKConnection = nil
            print("Anti-AFK: Disconnected idle connection")
        else
            print("Anti-AFK: No connection to disconnect")
        end
    end

    function m:RemoveReconnect()
        if ReconnectConnection then
            ReconnectConnection:Disconnect()
            ReconnectConnection = nil
            print("Reconnect: Disconnected error message connection")
        else
            print("Reconnect: No connection to disconnect")
        end
    end

    -- ===== QUEUE SYSTEM =====

    -- Add task to queue
    -- tool: Tool object to equip
    -- priority: Number (lower = higher priority, default = 5)
    -- taskFunction: Function to execute after tool is equipped (optional)
    -- callback: Function to call when task is complete (optional)
    function m:AddToQueue(_tool, _priority, _taskFunction, _callback)
        _priority = _priority or 5

        if not _tool or not _tool:IsA("Tool") then
            warn("Player:AddToQueue - Invalid tool provided")
            if _callback then _callback(false, "Invalid tool") end
            return false
        end

        local task = {
            Id = tick(), -- Unique identifier
            Tool = _tool,
            Priority = _priority,
            TaskFunction = _taskFunction,
            Callback = _callback,
            Timestamp = tick()
        }

        -- Insert task into queue
        table.insert(ToolQueue.Queue, task)

        print("🔧 Added tool to queue:", _tool.Name, "Priority:", _priority, "Queue size:", #ToolQueue.Queue)

        -- Start processing if not already processing
        if not ToolQueue.IsProcessing then
            print("🔧 Queue is already processing or empty, skipping...", self:GetQueueStatus())

            self:ProcessQueue()
        end

        return true
    end

    -- Process the queue
    function m:ProcessQueue()
        if ToolQueue.IsProcessing or #ToolQueue.Queue == 0 then
            print("🔧 Queue is already processing or empty, skipping...", self:GetQueueStatus())
            return -- Already processing or queue is empty
        end

        ToolQueue.IsProcessing = true

        while #ToolQueue.Queue > 0 do
            -- Sort queue by priority and timestamp to ensure correct order
            table.sort(ToolQueue.Queue, function(a, b)
                if a.Priority == b.Priority then
                    return a.Timestamp < b.Timestamp -- Earlier added first
                end
                return a.Priority < b.Priority -- Lower priority number first
            end)
            local currentTask = table.remove(ToolQueue.Queue, 1) -- Take first (highest priority) task
            ToolQueue.CurrentTask = currentTask

            print("🔧 Processing tool queue task:", currentTask.Tool.Name)

            -- Equip the tool, ensure it is equipped before proceeding
            if self:GetEquippedTool() ~= currentTask.Tool then
                self:EquipTool(currentTask.Tool)
                task.wait(0.5) -- Small delay to ensure tool is equipped
            end

            -- Execute task function if provided and wait for completion
            local success, result = pcall(function()
                return currentTask.TaskFunction()
            end)

            if currentTask.Callback then
                local callbackSuccess, callbackErr = pcall(currentTask.Callback, success, result)
                if not callbackSuccess then
                    warn("Callback error for tool:", currentTask.Tool.Name, "Error:", callbackErr)
                end
            end

            print("Task execution finished")
            -- task.wait(0.5)
            self:UnequipTool() -- Unequip after task

            ToolQueue.CurrentTask = nil
            task.wait(0.1) -- Small delay between tasks
        end

        ToolQueue.IsProcessing = false
        print("🔧 Queue processing completed")
    end

    -- Get current queue status
    function m:GetQueueStatus()
        return {
            queueSize = #ToolQueue.Queue,
            isProcessing = ToolQueue.IsProcessing,
            currentTask = ToolQueue.CurrentTask and ToolQueue.CurrentTask.Tool.Name or nil
        }
    end

    -- Clear the queue
    function m:ClearQueue()
        ToolQueue.Queue = {}
        ToolQueue.IsProcessing = false
        ToolQueue.CurrentTask = nil
        print("🔧 Tool queue cleared")
    end

    -- Remove specific task from queue by tool name
    function m:RemoveFromQueue(_toolName)
        if not _toolName then return false end

        for i = #ToolQueue.Queue, 1, -1 do
            if ToolQueue.Queue[i].Tool.Name == _toolName then
                table.remove(ToolQueue.Queue, i)
                print("🔧 Removed from queue:", _toolName)
                return true
            end
        end

        return false
    end

    function m:GetTaskByTool(_tool)
        local tasks = {}
        if not _tool then return nil end

        for _, task in ipairs(ToolQueue.Queue) do
            if task.Tool == _tool then
                table.insert(tasks, task)
            end
        end

        return #tasks > 0 and tasks or nil
    end

    function m:EquipTool(_tool)
        -- Validate inputs
        if not _tool or not _tool:IsA("Tool") then 
            warn("Player:EquipTool - Invalid tool provided")
            return false 
        end

        local humanoid = Core:GetHumanoid()
        local backpack = Core:GetBackpack()

        if not humanoid then
            warn("Player:EquipTool - Humanoid not found")
            return false
        end

        if not backpack then
            warn("Player:EquipTool - Backpack not found")
            return false
        end

        if _tool.Parent ~= backpack then
            warn("Player:EquipTool - Tool not in backpack")
            return false 
        end

        -- Try to equip with error handling
        local success, err = pcall(function()
            humanoid:EquipTool(_tool)
        end)

        if not success then
            warn("Player:EquipTool - Failed to equip:", err)
            return false
        end

        return true
    end

    function m:UnequipTool()    
        local humanoid = Core:GetHumanoid()
        if not humanoid then
            warn("Player:UnequipTool - Humanoid not found")
            return false
        end

        -- Try to unequip with error handling
        local success, err = pcall(function()
            humanoid:UnequipTools()
        end)

        if not success then
            warn("Player:UnequipTool - Failed to unequip:", err)
            return false
        end

        return true
    end

    function m:GetEquippedTool()
        local character = Core:GetCharacter()
        if not character then 
            warn("Player:GetEquippedTool - Character not found")
            return nil 
        end

        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") then
                return item
            end
        end

        return nil
    end

    function m:MoveToPosition(_position)
        local humanoid = Core:GetHumanoid()
        if humanoid then
            humanoid:MoveTo(_position)
        else
            warn("Player:MoveToPosition - Humanoid not found")
        end
    end

    function m:TeleportToPosition(_position)
        local hrp = Core:GetHumanoidRootPart()
        if hrp then
            hrp.CFrame = CFrame.new(_position)
            return true
        end
        return false
    end

    function m:GetPosition()
        local hrp = Core:GetHumanoidRootPart()
        return hrp and hrp.Position or Vector3.new(0, 0, 0)
    end

    function m:GetAllTools()
        local backpack = Core:GetBackpack()
        if not backpack then 
            warn("Player:GetAllTools - Backpack not found")
            return {} 
        end

        local tools = {}
        local success, err = pcall(function()
            for _, item in ipairs(backpack:GetChildren()) do
                if item:IsA("Tool") then
                    table.insert(tools, item)
                end
            end
        end)

        if not success then
            warn("Player:GetAllTools - Error getting tools:", err)
            return {}
        end

        return tools
    end

    function m:GetTool(_toolName)
        if not _toolName or type(_toolName) ~= "string" then
            warn("Player:GetTool - Invalid tool name")
            return nil
        end

        local backpack = Core:GetBackpack()
        if not backpack then
            warn("Player:GetTool - Backpack not found")
            return nil 
        end

        local tool = nil
        local success, err = pcall(function()
            tool = backpack:FindFirstChild(_toolName)
            if tool and not tool:IsA("Tool") then
                tool = nil
            end
        end)

        if not success then
            warn("Player:GetTool - Error finding tool:", err)
            return nil
        end

        if not tool then
            warn("Player:GetTool - Tool not found:", _toolName)
        end

        return tool
    end

    return m
end

-- Module: farm/garden.lua
EmbeddedModules["farm/garden.lua"] = function()
    local m = {}
    local Window
    local Core
    local Player
    local AutoHarvestThread
    local AutoHarvesting = false
    local BackpackConnection
    local PlantConnection
    local WateringConnection
    local PlantsLocation
    m.MailboxPosition = Vector3.new(0, 0, 0)

    function m:Init(_window, _core, _player)
        Window = _window
        Core = _core
        Player = _player

        local important = self:GetMyFarm():FindFirstChild("Important")
        PlantsLocation = important:FindFirstChild("Plant_Locations")

        local mailbox = self:GetMyFarm():FindFirstChild("Mailbox")
        if mailbox then
            m.MailboxPosition = mailbox:GetPivot().Position
        end

    end

    function m:GetMyFarm()
    	local farms = Core.Workspace.Farm:GetChildren()

    	for _, farm in next, farms do
            local important = farm.Important
            local data = important.Data
            local owner = data.Owner

    		if owner.Value == Core.LocalPlayer.Name then
    			return farm
    		end
    	end
    end

    function m:GetArea(_base)
        local center = _base:GetPivot()
    	local size = _base.Size

    	-- Bottom left
    	local x1 = math.ceil(center.X - (size.X/2))
    	local z1 = math.ceil(center.Z - (size.Z/2))

    	-- Top right
    	local x2 = math.floor(center.X + (size.X/2))
    	local z2 = math.floor(center.Z + (size.Z/2))

    	return x1, z1, x2, z2
    end

    function m:GetFarmCenterPosition()
        local farmParts = PlantsLocation:GetChildren()
        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        -- Calculate center from all farm parts
        local totalX, totalZ = 0, 0
        local totalY = 4 -- Default height for farm
        local partCount = 0

        for _, part in pairs(farmParts) do
            if part:IsA("BasePart") then
                local pos = part.Position
                totalX = totalX + pos.X
                totalZ = totalZ + pos.Z
                totalY = math.max(totalY, pos.Y + part.Size.Y/2) -- Use highest Y position
                partCount = partCount + 1
            end
        end

        if partCount > 0 then
            local centerX = totalX / partCount
            local centerZ = totalZ / partCount
            return Vector3.new(centerX, totalY, centerZ)
        end
    end

    function m:GetFarmFrontRightPosition()
        local farmParts = PlantsLocation:GetChildren()

        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        local farmLand = farmParts[1]
        if  m.MailboxPosition.Z > 0 then
            if farmParts[1]:GetPivot().X > farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        else
            if farmParts[1]:GetPivot().X < farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        end

        local x1, z1, x2, z2 = self:GetArea(farmLand)

        local x = math.max(x1, x2)
        local z = math.max(z1, z2)

        if m.MailboxPosition.Z > 0 then
            x = math.min(x1, x2)
            z = math.min(z1, z2)
        end

        return Vector3.new(x, 4, z)
    end

    function m:GetFarmFrontLeftPosition()
        local farmParts = PlantsLocation:GetChildren()

        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        local farmLand = farmParts[1]
        if  m.MailboxPosition.Z > 0 then
            if farmParts[1]:GetPivot().X < farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        else
            if farmParts[1]:GetPivot().X > farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        end

        local x1, z1, x2, z2 = self:GetArea(farmLand)

        local x = math.min(x1, x2)
        local z = math.max(z1, z2)

        if m.MailboxPosition.Z > 0 then
            x = math.max(x1, x2)
            z = math.min(z1, z2)
        end

        return Vector3.new(x, 4, z)
    end

    function m:GetFarmBackRightPosition()
        local farmParts = PlantsLocation:GetChildren()
        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        local farmLand = farmParts[1]
        if  m.MailboxPosition.Z > 0 then
            if farmParts[1]:GetPivot().X > farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        else
            if farmParts[1]:GetPivot().X < farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        end

        local x1, z1, x2, z2 = self:GetArea(farmLand)

        local x = math.max(x1, x2)
        local z = math.min(z1, z2)

        if m.MailboxPosition.Z > 0 then
            x = math.min(x1, x2)
            z = math.max(z1, z2)
        end

        return Vector3.new(x, 4, z)
    end

    function m:GetFarmBackLeftPosition()
        local farmParts = PlantsLocation:GetChildren()
        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        local farmLand = farmParts[1]
        if  m.MailboxPosition.Z > 0 then
            if farmParts[1]:GetPivot().X < farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        else
            if farmParts[1]:GetPivot().X > farmParts[2]:GetPivot().X then
                farmLand = farmParts[2]
            end
        end

        local x1, z1, x2, z2 = self:GetArea(farmLand)

        local x = math.min(x1, x2)
        local z = math.min(z1, z2)

        if m.MailboxPosition.Z > 0 then
            x = math.max(x1, x2)
            z = math.max(z1, z2)
        end

        return Vector3.new(x, 4, z)
    end

    function m:GetFarmRandomPosition()
        local farmParts = PlantsLocation:GetChildren()

        if #farmParts < 1 then
            return Vector3.new(0, 4, 0)
        end

        local FarmLand = farmParts[math.random(1, #farmParts)]

        local x1, z1, x2, z2 = self:GetArea(FarmLand)
        local x = math.random(x1, x2)
        local z = math.random(z1, z2)

        return Vector3.new(x, 4, z)
    end

    return m
end

-- Module: event/ghoul/ui.lua
EmbeddedModules["event/ghoul/ui.lua"] = function()
    local m = {}

    local Window
    local Quest
    local Shop

    function m:Init(_window, _quest, _shop)
        Window = _window
        Quest = _quest
        Shop = _shop


        local tab = Window:AddTab({
            Name = "Ghoul Event",
            Icon = "👻",
        })
        self:GhoulSection(tab)
        self:SeedShopSection(tab)
        self:CreepyCrittersSection(tab)
        self:DevilishDecorSection(tab)
    end

    function m:GhoulSection(tab)
        local eventAccordion = tab:AddAccordion({
            Title = "Ghoul Event",
            Icon = "👻",
            Default = false,
        })

        eventAccordion:AddToggle({
            Name = "Auto Submit Ghoul Quest Items 👻",
            Default = false,
            Flag = "AutoSubmitGhoulQuest",
            Callback = function(Value)
                if Value then
                    Quest:StartAutoSubmitEventPlants()
                end
            end,
        })
    end

    function m:SeedShopSection(tab)
        local merchant = "Spooky Seeds"
        local accordion = tab:AddAccordion({
            Title = "Spooky Seeds Shop",
            Icon = "🎃",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Item to Buy 🛒",
            Options = {"loading ..."},
            Placeholder = "Select Item",
            MultiSelect = true,
            Flag = "SpookyShopItem",
            OnInit =  function(api, optionsData)
                local items = Shop:GetItemRepository(merchant)

                local itemNames = {}
                for itemName, _ in pairs(items) do
                    table.insert(itemNames, itemName)
                end

                optionsData.updateOptions(itemNames)
            end
        })

        accordion:AddToggle({
            Name = "Auto Buy Spooky Shop Items 🛒",
            Default = false,
            Flag = "AutoBuySpookyShop",
            Callback = function(Value)
                if Value then
                    Quest:StartAutoBuyEventItems()
                end
            end,
        })
    end

    function m:CreepyCrittersSection(tab)
        local merchant = "Creepy Critters"
        local accordion = tab:AddAccordion({
            Title = "Creepy Critters Shop",
            Icon = "🦇",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Item to Buy 🛒",
            Options = {"loading ..."},
            Placeholder = "Select Item",
            MultiSelect = true,
            Flag = "CreepyShopItem",
            OnInit =  function(api, optionsData)
                local items = Shop:GetItemRepository(merchant)

                local itemNames = {}
                for itemName, _ in pairs(items) do
                    table.insert(itemNames, itemName)
                end

                optionsData.updateOptions(itemNames)
            end
        })

        accordion:AddToggle({
            Name = "Auto Buy Creepy Shop Items 🛒",
            Default = false,
            Flag = "AutoBuyCreepyShop",
            Callback = function(Value)
                if Value then
                    Quest:StartAutoBuyEventItems()
                end
            end,
        })
    end

    function m:DevilishDecorSection(tab)
        local merchant = "Devilish Decor"
        local accordion = tab:AddAccordion({
            Title = "Devilish Decor Shop",
            Icon = "🕸️",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Item to Buy 🛒",
            Options = {"loading ..."},
            Placeholder = "Select Item",
            MultiSelect = true,
            Flag = "DevilishShopItem",
            OnInit =  function(api, optionsData)
                local items = Shop:GetItemRepository(merchant)

                local itemNames = {}
                for itemName, _ in pairs(items) do
                    table.insert(itemNames, itemName)
                end

                optionsData.updateOptions(itemNames)
            end
        })

        accordion:AddToggle({
            Name = "Auto Buy Devilish Shop Items 🛒",
            Default = false,
            Flag = "AutoBuyDevilishShop",
            Callback = function(Value)
                if Value then
                    Quest:StartAutoBuyEventItems()
                end
            end,
        })
    end

    return m
end

-- Load module helper function
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original require
    return require(url)
end

-- Main Script
-- Main entry point
local EzUI = loadModule("https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua")
-- Import local modules
local CoreModule = loadModule("../module/core.lua")
local PlayerModule = loadModule("../module/player.lua")
local Discord = loadModule("../module/discord.lua")
local ServerUI = loadModule("server/ui.lua")

-- Farm modules
local GardenModule = loadModule("farm/garden.lua")
local PlantModule = loadModule("farm/plant.lua")
local FarmUI = loadModule("farm/ui.lua")

-- Quest module
local AscensionModule = loadModule("quest/ascension.lua")
local QuestUI = loadModule("quest/ui.lua")

-- Shop modules
local ShopModule = loadModule("shop/shop.lua")
local ShopSeedModule = loadModule("shop/seed.lua")
local ShopGearModule = loadModule("shop/gear.lua")
local ShopEggModule = loadModule("shop/egg.lua")
local ShopSeasonPassModule = loadModule("shop/season_pass.lua")
local ShopTravelingModule = loadModule("shop/traveling.lua")
local ShopPremiumModule = loadModule("shop/premium.lua")
local ShopUI = loadModule("shop/ui.lua")

-- -- Pet modules
local PetTeamModule = loadModule("pet/team.lua")
local PetWebhook = loadModule("pet/webhook.lua")
local EggModule = loadModule("pet/egg.lua")
local PetModule = loadModule("pet/pet.lua")
local PetUI = loadModule("pet/ui.lua")

-- Automation modules
local CraftingModule = loadModule("auto/crafting.lua")
local AutoUI = loadModule("auto/ui.lua")

-- Inventory modules
local InventoryModule = loadModule("inventory/inventory.lua")
local InventoryUI = loadModule("inventory/ui.lua")

-- Event modules
local GhoulQuest = loadModule("event/ghoul/quest.lua")
local GhoulShop = loadModule("event/ghoul/shop.lua")
local GhoulUI = loadModule("event/ghoul/ui.lua")

-- Notification module
local NotificationUI = loadModule("notification/ui.lua")

local configFolder = "EzHub/EzGarden"

-- Initialize window
local window = EzUI:CreateNew({
    Title = "EzGarden",
    Width = 700,
    Height = 400,
    Opacity = 0.9,
    AutoAdapt = true,
    AutoShow = false,
    FolderName = configFolder,
    FileName = "settings",
})

-- Update window close callback
window:SetCloseCallback(function()
    print("window is closing! Performing cleanup...")

    -- Remove Anti-AFK connections
    PlayerModule:RemoveAntiAFK()

    -- Stop all queued tasks
    PlayerModule:ClearQueue()

    -- Stop all active loops
    CoreModule:StopAllLoops()

    print("Cleanup completed!")
end)

petTeamsConfig = EzUI:NewConfig({
    FolderName = configFolder,
    FileName = "PetTeams",
})

petTeamsConfig:Load()

-- Wait load config
task.wait(1) -- Ensure config is loaded

-- Player
PlayerModule:Init(CoreModule)

-- Farm
GardenModule:Init(window, CoreModule, PlayerModule)
PlantModule:Init(window, CoreModule, PlayerModule, GardenModule)
FarmUI:init(window, PlayerModule, GardenModule, PlantModule)
FarmUI:CreateFarmTab()
print("Farm initialized")

-- -- Pet
PetTeamModule:Init(CoreModule, PlayerModule, window, petTeamsConfig, GardenModule)
PetWebhook:Init(window, CoreModule, Discord)
PetModule:Init(CoreModule, PlayerModule, window, GardenModule, PetTeamModule, PetWebhook)
EggModule:Init(CoreModule, PlayerModule, window, GardenModule, PetModule, PetWebhook)
PetUI:Init(window, PetTeamModule, EggModule, PetModule, GardenModule, PlayerModule)
PetUI:CreatePetTab()
print("Pet initialized")

-- Automation
CraftingModule:Init(window, CoreModule, PlantModule)
AutoUI:Init(window, CoreModule, CraftingModule)
print("Automation initialized")

-- Shop
ShopModule:Init(CoreModule)
ShopSeedModule:Init(window, CoreModule, ShopModule)
ShopGearModule:Init(window, CoreModule, ShopModule)
ShopEggModule:Init(window, CoreModule, ShopModule)
ShopTravelingModule:Init(window, CoreModule, ShopModule)
ShopSeasonPassModule:Init(window, CoreModule, ShopModule)
ShopPremiumModule:Init(window, CoreModule)
ShopUI:Init(window, CoreModule, ShopEggModule, ShopSeedModule, ShopGearModule, ShopSeasonPassModule, ShopTravelingModule, ShopPremiumModule)
ShopUI:CreateShopTab()
print("Shop initialized")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

-- Quest
AscensionModule:Init(window, CoreModule, PlantModule, PlayerModule)
QuestUI:Init(window, CoreModule, AscensionModule)
QuestUI:CreateQuestTab()
print("Quest initialized")

-- Inventory
InventoryModule:Init(CoreModule, PlayerModule, window)
InventoryUI:Init(window, InventoryModule, PetModule)
InventoryUI:CreateTab()
print("Inventory initialized")

-- Event
GhoulQuest:Init(window, CoreModule)
GhoulShop:Init(window, CoreModule, ShopModule)
GhoulUI:Init(window, GhoulQuest, GhoulShop)

-- Server
ServerUI:Init(window, CoreModule, PlayerModule, GardenModule)
ServerUI:CreateServerTab()
print("Server initialized")

-- -- Notification
NotificationUI:Init(window, PetWebhook)
NotificationUI:CreateNotificationTab()